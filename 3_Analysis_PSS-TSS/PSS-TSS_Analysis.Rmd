---
title: "Analyze PSS and TSS data of 5' sensing experiment"
author:
- affiliation: AG Annegret Wilde, Institute of Biology III
  name: "Ute Hoffmann"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_document:
    fig_width: 15
    fig_height: 8
    theme: united
    toc: yes
    number_sections: true
  pdf_document:
    toc: yes
    number_sections: true
bibliography: bibliography.bib
---

```{r setup, include=FALSE, echo=FALSE}
require("knitr")
opts_knit$set(root.dir = "/data/Dokumente/uni/Doktorarbeit/T161V_analyses/00_Manuscript/Code/3_Analysis_PSS-TSS/")
library(tidyverse)
library(DESeq2)
library(edgeR)
library(ggplot2)
library(ggrepel)
library(ggpubr)
library(pheatmap)
library(RColorBrewer)
library(vsn)
library(GenomicRanges)
library(Biostrings)
library(rtracklayer)
library(viridis)
library(colorblindr)
library(clusterProfiler)
```

```{r, echo=FALSE}
# Colors: (based on scale_fill_OkabeIto())
# values=c("#e69f00ff", "#005a96ff", "000000ff") - e6... : rne(5p), 005...: rne(WT), 000..: WT
#c("#005a96b2", "#e69f00b2", "d3d3d3b2") # in transparency, d3d3d3b2 if none of both strains
# Colours (ColorBrewer Dark2) for PSS / TSS:
# values=c("PSS"="#4e9879ff", "TSS"="#c96928ff")

# some functions which are incredibly handy

#### Functions for plotting and handling DESeq2 objects

count_up_down <- function(deseq2_dframe, foldchange=1, padjusted=0.01)
{ # input: DESeq2 results object / data frame; foldchange and padjusted; returns numbers of features in DESeq2 results object differentially expressed according to cut-offs
  deseq2_dframe <- as.data.frame(subset(deseq2_dframe, !is.na(deseq2_dframe$padj)))
  # create vectors of down- or upregulated features, give out their numbers
  down <- deseq2_dframe$log2FoldChange < -foldchange & deseq2_dframe$padj < padjusted
  up <- deseq2_dframe$log2FoldChange > foldchange & deseq2_dframe$padj < padjusted
  
  print(paste("number of features down: ", sum(down)))
  print(paste("number of features up: ", sum(up)))
}

return_up_down <- function(deseq2_dframe, foldchange=1, padjusted=0.01)
{
  deseq2_dframe <- subset(deseq2_dframe, !is.na(deseq2_dframe$padj))
  # create vectors of down- or upregulated features, give out their numbers
  down <- deseq2_dframe$log2FoldChange < -foldchange & deseq2_dframe$padj < padjusted
  up <- deseq2_dframe$log2FoldChange > foldchange & deseq2_dframe$padj < padjusted
  
  vector_differentiallyExpressed <- c(row.names(deseq2_dframe)[down],row.names(deseq2_dframe)[up])
  return(vector_differentiallyExpressed)
}

volcanoPlot_ggplot <-  function(deseq2_dframe, foldchange=1, padjusted=0.01, color=TRUE, text=FALSE, numbers=TRUE, lines_padj_FC=TRUE)
{ # plots Volcano Plot for DESeq2 results object
  # compare: https://biocorecrg.github.io/CRG_RIntroduction/volcano-plots.html
  
  # The significantly differentially expressed genes are the ones found in the upper-left and upper-right corners.
  # Add a column to the data frame to specify if they are UP- or DOWN- regulated (log2FoldChange respectively positive or negative)
  
  # add a column of NAs
  df_copy <- as.data.frame(deseq2_dframe)
  df_copy$diffexpressed <- "NO"
  # if log2Foldchange > 0.6 and pvalue < 0.05, set as "UP" 
  df_copy$diffexpressed[df_copy$log2FoldChange > foldchange & df_copy$padj < padjusted] <- "UP"
  # if log2Foldchange < -0.6 and pvalue < 0.05, set as "DOWN"
  df_copy$diffexpressed[df_copy$log2FoldChange < -foldchange & df_copy$padj < padjusted] <- "DOWN"
  
  # prepare labels of plot
  df_copy$delabel <- NA
  df_copy$delabel[df_copy$diffexpressed != "NO"] <- row.names(df_copy)[df_copy$diffexpressed != "NO"]
  
  # Plot
  p <- ggplot(data=df_copy, aes(x=log2FoldChange, y=-log10(padj), col=diffexpressed, label=delabel)) + geom_point(alpha=0.3, show.legend = FALSE) + 
    theme_light() + labs(y="-Log10(p.adj_BH)", x="Log2FC") + theme(legend.position = "none")
  
  # color points
  mycolors <- c("#e69f00b2","#005a96b2",  "#d3d3d3b2")
  names(mycolors) <- c("DOWN", "UP", "NO")
  p <- p + scale_colour_manual(values = mycolors)
  
  # Add vertical lines for log2FoldChange thresholds, and one horizontal line for the p-value threshold 
  if(lines_padj_FC){
    p <- p + geom_vline(xintercept=c(-foldchange, foldchange), linetype="dotted") +
      geom_hline(yintercept=-log10(padjusted), linetype="dotted") # http://www.sthda.com/english/wiki/ggplot2-line-types-how-to-change-line-types-of-a-graph-in-r-software
  }
  
  # Now write down the name of genes beside the points...
  # Create a new column "delabel" to de, that will contain the name of genes differentially expressed (NA in case they are not)
  if(text){
    p <- p + geom_text_repel(fontface="italic")   #geom_text()
  }
  
  return(p)
}

MAplot_ggplot <-  function(deseq2_dframe, foldchange=1, padjusted=0.05, color=TRUE, text=FALSE, numbers=TRUE, lines_padj_FC=TRUE, y_axis_label="Log2FC")
{ # plots MAplot for DESeq2 results object
  # add a column of NAs
  df_copy <- as.data.frame(deseq2_dframe)
  df_copy$diffexpressed <- "NO"
  # if log2Foldchange > 0 and pvalue < 0.05, set as "UP" 
  df_copy$diffexpressed[df_copy$log2FoldChange > 0 & df_copy$padj < padjusted] <- "UP"
  # if log2Foldchange < 0 and pvalue < 0.05, set as "DOWN"
  df_copy$diffexpressed[df_copy$log2FoldChange < 0 & df_copy$padj < padjusted] <- "DOWN"
  
  # prepare labels of plot
  df_copy$delabel <- NA
  df_copy$delabel[df_copy$diffexpressed != "NO"] <- row.names(df_copy)[df_copy$diffexpressed != "NO"]
  
  # Plot
  p <- ggplot(data=df_copy, aes(x=baseMean, y=log2FoldChange, col=diffexpressed, label=delabel)) + geom_point(size=0.5, show.legend = FALSE) + 
    theme_light() + labs(y=y_axis_label, x="Mean of Normalized Counts") + theme(legend.position = "none") + scale_x_continuous(trans='log10')
  
  # color points
  mycolors <- c("#e69f00ff","#005a96ff",  "#d3d3d3ff")
  names(mycolors) <- c("DOWN", "UP", "NO")
  p <- p + scale_colour_manual(values = mycolors)
  
  # Add vertical lines for log2FoldChange thresholds, and one horizontal line for the p-value threshold 
  if(lines_padj_FC){
    p <- p + geom_hline(yintercept=c(-foldchange, 0, foldchange), linetype="dotted")
  }
  
  # Now write down the name of genes beside the points...
  # Create a new column "delabel" to de, that will contain the name of genes differentially expressed (NA in case they are not)
  if(text){
    p <- p + geom_text_repel(fontface="italic")   #geom_text()
  }
  
  return(p)
}

PCA_plot <- function(dds, title){
  # plots PCA for DESeq2 Data Set object, uses rlog, assumes DESeq2 data set object for dWT / WT / TV comparison
  rld <- rlog(dds)
  pcaData <- plotPCA(rld, intgroup=c("strain"), returnData=TRUE)
  percentVar <- round(100 * attr(pcaData, "percentVar"))
  ggplot(pcaData, aes(PC1, PC2, color=strain)) +
    geom_point(size=3) +
    xlab(paste0("PC1: ",percentVar[1],"% variance")) +
    ylab(paste0("PC2: ",percentVar[2],"% variance")) + 
    coord_fixed() + theme_light() + scale_color_manual(name="Strain", values=c("#000000ff", "#005a96ff", "#e69f00ff"), breaks=c("WT", "dWT", "TV"), labels=c("WT", "rne(WT)", "rne(5p)")) + 
    theme(legend.position="bottom", legend.box="vertical", legend.margin=margin(t=-0.2, r=0, b=0, l=0, unit="cm"))  + 
    labs(title=title)
}

heatmap_plot <- function(dds, title){
  # plots heat map for DESeq2 Data Set object, uses rlog
  dat <- assay(rlog(dds))
  dists_rl <- dist(t(dat))
  mat <- as.matrix(dists_rl)
  #rownames(mat) <- c(rep("rne(WT)", 3),rep("WT", 3), rep("TV",2))
  colnames(mat) <- NULL
  colors <- colorRampPalette(rev(brewer.pal(9, "Blues")))(255)
  pheatmap(
    mat,
    clustering_distance_rows = dists_rl,
    clustering_distance_cols = dists_rl,
    col = colors,
    main = "Sample-to-sample distances"
  )
}

PCA_plot_PSSTSS <- function(dds, title){
  # plots PCA for PSS / TSS comparison of DESeq Data set
  rld <- rlog(dds)
  pcaData <- plotPCA(rld, intgroup=c("type", "strain"), returnData=TRUE)
  percentVar <- round(100 * attr(pcaData, "percentVar"))
  return(ggplot(pcaData, aes(PC1, PC2, color=strain, shape=type)) +
    geom_point(size=3) +
    xlab(paste0("PC1: ",percentVar[1],"% variance")) +
    ylab(paste0("PC2: ",percentVar[2],"% variance")) + 
    coord_fixed() + theme_light() + scale_color_manual(name="Strain", values=c("#000000ff", "#005a96ff", "#e69f00ff"), breaks=c("WT", "dWT", "TV"), labels=c("WT", "rne(WT)", "rne(5p)")) +
    theme(legend.position="bottom", legend.box="vertical", legend.margin=margin(t=-0.2, r=0, b=0, l=0, unit="cm")) +
    labs(title=title) + scale_shape_discrete(name="", breaks=c("PSS", "TSS"), labels=c("PSS", "TSS")))
}

heatmap_plot_PSSTSS <- function(dds, title){
  # plots heat map for PSS / TSS comparison of DESeq Data set
  dat <- assay(rlog(dds))
  dists_rl <- dist(t(dat))
  mat <- as.matrix(dists_rl)
  #rownames(mat) <- c(rep(c("rne(5p) 0h", "rne(5p) 1h"), 3),rep(c("rne(WT) 0h", "rne(WT) 1h"), 3))
  colnames(mat) <- NULL
  colors <- colorRampPalette(rev(brewer.pal(9, "Blues")))(255)
  pheatmap(
    mat,
    clustering_distance_rows = dists_rl,
    clustering_distance_cols = dists_rl,
    col = colors,
    main = "Sample-to-sample distances"
  )
}

pvaluePlot <- function(result_object, title_plot){ 
  # plots histogram of distribution of p values in DESeq2 results object
  use <- result_object$baseMean > metadata(result_object)$filterThreshold
  h1 <- hist(result_object$pvalue[!use], breaks=0:50/50, plot=FALSE)
  h2 <- hist(result_object$pvalue[use], breaks=0:50/50, plot=FALSE)
  colori <- c(`filtered (low count)`="khaki", `not filtered`="powderblue")
  barplot(height = rbind(h1$counts, h2$counts), beside = FALSE,
        col = colori, space = 0, main = paste("Histogram of p-values for", title_plot), ylab="Frequency", xlab="P-values")
  text(x = c(0, length(h1$counts)), y = 0, label = paste(c(0,1)),
     adj = c(0.5,1.7), xpd=NA)
  legend("topright", fill=rev(colori), legend=rev(names(colori)))
}

#### Functions to work on GRanges objects
create_GRanges_object <- function(pos_list, base_means){
  # creates GRanges object from pos_list and adds additional info about base_means (base_means input as vector)
  # input: pos_list: List of positions which should be used for GRanges object: each element in list: [1]: contig name, [2]: nt-position (=start/stop), [3]: strand information
  # with some extra constructs (e.g. as.integer(map_chr(pos_list, pluck, 2)) one can work around for-construct, but it's slower https://rstudio-education.github.io/tidyverse-cookbook/transform-lists-and-vectors.html
  
  # initialise vectors
  seq_names <- c()
  starts <- c()
  stops <- c()
  strands <- c()

  for(i in 1:length(pos_list)){
    seq_names[i] <- pos_list[[i]][1]
    starts[i] <- as.integer(pos_list[[i]][2])
    stops[i] <- as.integer(pos_list[[i]][2])
    if(pos_list[[i]][3]=="plus"){
      strands[i] <- "+"
    }else if(pos_list[[i]][3]=="minus"){
      strands[i] <- "-"
    }
  }
  
  GRanges_object <- GRanges(seqnames=seq_names,
      ranges=IRanges(starts, stops), strand=strands, baseMean=base_means)

  return(GRanges_object)
}

create_GRanges_object_from_resObject <- function(DESeq2_resObject, foldchange, padjusted, up=TRUE){
  # input: DESeq2 results object, + foldchange and padjusted cut-offs which should be used to only select certain set of positions, up=TRUE -> extract positions with log2FC > foldchange, else (up=FALSE) -> extract positions with log2FC < foldchange 
  if(up){
  subset_resObject <- subset(DESeq2_resObject, DESeq2_resObject$log2FoldChange>foldchange & DESeq2_resObject$padj < padjusted)
  } else{
  subset_resObject <- subset(DESeq2_resObject, DESeq2_resObject$log2FoldChange<foldchange & DESeq2_resObject$padj < padjusted)
  }
  positions<- base::strsplit(row.names(subset_resObject), "-")
  rangesObject <- create_GRanges_object(positions, subset_resObject$baseMean)
  return(rangesObject)
}

advanced_reduce <- function(rangesObject){
  # function to reduce rangesObject (join adjacent positions to one longer position), and at same time trim positions with width > 0 to the one with highest population of reads (highest baseMean)
  new_ranges <- GenomicRanges::reduce(rangesObject)
  redundant_pos <- new_ranges[which(width(new_ranges)>1)]
  
  indices_new_ranges <- which(width(new_ranges)>1)
  
  starts <- start(new_ranges)
  ends <- end(new_ranges)
  strands <- strand(new_ranges)
  seqname_vec <- seqnames(new_ranges)
  
  for(i in indices_new_ranges){
      # extract baseMeans from original object    
      ranges_index <- which(start(rangesObject) %in% starts[i]:ends[i] & strand(rangesObject)==strands[i] & seqnames(rangesObject)==seqname_vec[i])
      baseMeans <- rangesObject[ranges_index]$baseMean
      positions <- starts[i]:ends[i]
  
      start(new_ranges[i]) <- positions[which(baseMeans==max(baseMeans))]
      end(new_ranges[i]) <- positions[which(baseMeans==max(baseMeans))]
  }

  return(new_ranges)
}

advanced_reduce_withBaseMeans <- function(rangesObject){
  # function to reduce rangesObject (join adjacent positions to one longer position), and at same time trim positions with width > 0 to the one with highest population of reads (highest baseMean)
  new_ranges <- GenomicRanges::reduce(rangesObject)
  new_ranges$baseMeans <- NA
  redundant_pos <- new_ranges[which(width(new_ranges)>1)]
  
  indices_new_ranges <- which(width(new_ranges)>1)
  indices_new_ranges_width0 <- which(width(new_ranges)==1)
  
  starts <- start(new_ranges)
  ends <- end(new_ranges)
  strands <- strand(new_ranges)
  seqname_vec <- seqnames(new_ranges)
  
  for(i in 1:length(new_ranges)){
      # extract baseMeans from original object    
      ranges_index <- which(start(rangesObject) %in% starts[i]:ends[i] & strand(rangesObject)==strands[i] & seqnames(rangesObject)==seqname_vec[i])
      baseMeans <- rangesObject[ranges_index]$baseMean
      positions <- starts[i]:ends[i]
  
      start(new_ranges[i]) <- positions[which(baseMeans==max(baseMeans))]
      end(new_ranges[i]) <- positions[which(baseMeans==max(baseMeans))]
      new_ranges[i]$baseMeans <- max(baseMeans)
  }

  return(new_ranges)
}

extract_RNA_sequences <- function(Ranges_object, sequence_object, len=10){
  # function returns RNAStringSet with sequences centred around start positions - assumes width 1! Otherwise on minus strand: stop codon instead of start position!, +/- len (e.g. 10nt downstream + 10nt upstream), position len+1 in returned sequence corresponds to original start position
  
  if(sum(width(Ranges_object)>1)>0){
    print("Attention! It seems as if not all features in the input Ranges object have width=1 - be aware that output RNA strings are centred around the start positions, irrespective if located on plus or minus strand!")
  }
  
  # extract lengths of sequences
  lengths <- c()
  for(i in 1:length(sequence_object)){
    lengths[i] <- width(sequence_object[i])
  }
  names(lengths) <- names(sequence_object)
  
  # extract info about what to extract
  seqs <- as.character(data.frame(Ranges_object)[,1])
  starts <- start(Ranges_object)
  stops <- starts + len-1
  starts <- starts -len
  strands <- data.frame(Ranges_object)[,5]

  # initialise vector
  peak_set_plusMinus <- c("a")

  # starts < 0
  indices <- which(starts<0)
  peak_set_plusMinus[indices] <- RNAStringSet(DNAStringSet(paste(subseq(sequence_object[seqs[indices]],start=lengths[seqs[indices]]-(-starts[indices]), end=lengths[seqs[indices]]),subseq(sequence_object[seqs[indices]],start=1, end=stops[indices]),sep="")))
  
  # stops > lengths
  indices <- which(stops>lengths[seqs])
  peak_set_plusMinus[indices] <- RNAStringSet(DNAStringSet(paste(subseq(sequence_object[seqs[indices]],start=starts[indices], end=lengths[seqs[indices]]),subseq(sequence_object[seqs[indices]],start=1, end=stops[indices]-lengths[seqs[indices]]),sep="")))

  # rest
  indices <- which(!(starts<0 | stops>lengths[seqs]))
  peak_set_plusMinus[indices] <- RNAStringSet(subseq(sequence_object[seqs[indices]], start=starts[indices], end=stops[indices]))

  # transform to RNAStringSet
  peak_set_plusMinus <- RNAStringSet(peak_set_plusMinus)
  
  # include reverse Complement
  indices <- which(strands=="-")
  peak_set_plusMinus[indices] <- RNAStringSet(reverseComplement(peak_set_plusMinus[indices]))

  names(peak_set_plusMinus) <- paste("peak", seq(1:length(peak_set_plusMinus)), sep="_")
  
  return(peak_set_plusMinus)
}

extract_DNA_sequences <- function(Ranges_object, sequence_object, len=10, only_upstream=FALSE){
  # function returns DNAStringSet with sequences centred around positions - width taken into account, +/- len (e.g. 10nt downstream + 10nt upstream). If only_upstream = TRUE: only upstream sequence is returned
  
  # extract lengths of sequences
  lengths <- c()
  for(i in 1:length(sequence_object)){
    lengths[i] <- width(sequence_object[i])
  }
  names(lengths) <- names(sequence_object)
  
  # extract info about what to extract
  strands <- data.frame(Ranges_object)[,5]
  seqs <- as.character(data.frame(Ranges_object)[,1])
  stops <- c()
  starts <- c()
  if(only_upstream){
    plus_strand <- which(strand(Ranges_object)=="+")
    minus_strand <- which(strand(Ranges_object)=="-")
    
    stops[plus_strand] <- start(Ranges_object[plus_strand])
    starts[plus_strand] <- start(Ranges_object[plus_strand])-len

    starts[minus_strand] <- end(Ranges_object[minus_strand])
    stops[minus_strand] <- end(Ranges_object[minus_strand])+len
      
  }else{
    starts <- start(Ranges_object)
    ends <- end(Ranges_object)
    stops <- ends + len-1
    starts <- starts -len
  }

  # initialise vector
  peak_set_plusMinus <- c("a")

  # starts < 0
  indices <- which(starts<0)
  peak_set_plusMinus[indices] <- DNAStringSet(paste(subseq(sequence_object[seqs[indices]],start=lengths[seqs[indices]]-(-starts[indices]), end=lengths[seqs[indices]]),subseq(sequence_object[seqs[indices]],start=1, end=stops[indices]),sep=""))
  
  # stops > lengths
  indices <- which(stops>lengths[seqs])
  peak_set_plusMinus[indices] <- DNAStringSet(paste(subseq(sequence_object[seqs[indices]],start=starts[indices], end=lengths[seqs[indices]]),subseq(sequence_object[seqs[indices]],start=1, end=stops[indices]-lengths[seqs[indices]]),sep=""))

  # rest
  indices <- which(!(starts<0 | stops>lengths[seqs]))
  peak_set_plusMinus[indices] <- DNAStringSet(subseq(sequence_object[seqs[indices]], start=starts[indices], end=stops[indices]))

  # transform to DNAStringSet
  peak_set_plusMinus <- DNAStringSet(peak_set_plusMinus)
  
  # include reverse Complement
  indices <- which(strands=="-")
  peak_set_plusMinus[indices] <- DNAStringSet(reverseComplement(peak_set_plusMinus[indices]))

  names(peak_set_plusMinus) <- paste("peak", seq(1:length(peak_set_plusMinus)), sep="_")
  
  return(peak_set_plusMinus)
}


## functions for functional enrichment

# read in term_to_gene and term_to_name for enricher()
term_to_gene <- read.table("input/20200113_locusTags_GOterms.tsv", sep="\t", header=T)
tmp <- term_to_gene[,2]
tmp2 <- term_to_gene[,1]
term_to_gene[,1] <- tmp
term_to_gene[,2] <- tmp2
rm(tmp, tmp2)
names(term_to_gene) <- c("GO_ID", "locus_tag")

term_to_name <- read.delim("input/term_to_name.csv", sep="\t", header=T)

# code functional enrichment function
go_functional_enrichment_locusList <- function(list_of_genes, universe_tags, write=FALSE, path=""){
  ego <- enricher(list_of_genes, universe=universe_tags, TERM2GENE = term_to_gene, TERM2NAME=term_to_name)
  print(head(ego))
  
  if(write){
    write.csv(ego, path)
  }
  return(ego)
}

kegg_functional_enrichment_locusList <- function(list_of_genes, universe_tags, write=FALSE, path=""){

  ekegg <- enrichKEGG(gene         = list_of_genes,
                               universe      = universe_tags,
                               organism     = 'syn',
                               pAdjustMethod = "BH",
                               pvalueCutoff  = 0.05,
                               qvalueCutoff  = 0.05)
  print(ekegg[,1:7])
  if(write){
    write.csv(ekegg, path)
  }
  return(ekegg)
}

save_gff <- function(Ranges, file_path, basic_name){
  rtracklayer::export(Ranges, paste(file_path, basic_name, "_all.gff", sep=""))
  rtracklayer::export(subset(Ranges, seqnames(Ranges)=="BA000022.2"), paste(file_path, basic_name, "_chromo.gff", sep=""))
  rtracklayer::export(subset(Ranges, seqnames(Ranges)=="AP004311.1"), paste(file_path, basic_name, "_pSYSA.gff", sep=""))
  rtracklayer::export(subset(Ranges, seqnames(Ranges)=="AP004310.1"), paste(file_path, basic_name, "_pSYSM.gff", sep=""))
  rtracklayer::export(subset(Ranges, seqnames(Ranges)=="AP004312.1"), paste(file_path, basic_name, "_pSYSG.gff", sep=""))
  rtracklayer::export(subset(Ranges, seqnames(Ranges)=="AP006585.1"), paste(file_path, basic_name, "_pSYSX.gff", sep=""))
}
```

# Aim of the analysis

Aim of this analysis is to identiy processing sites (PSS) which are dependent on RNase E 5' sensing by comparing PSS detected in two strains: *rne*(5p) and *rne*(WT). Also, PSS affected by overexpressing RNase E and RNase HII will be identified by comparing *rne*(WT) with wild-type *Synechocystis* (WT). The respective sets of TSS will be further analysed, e.g. for secondary structures. *rne*(WT) will partially be reffered to as "dWT", *rne*(5p) as "dTV" or "TV".

```{r}
#import gff for anno-TSS
anno_TSS <- unique(rtracklayer::import("input/Kopf_TSS.gff")) # 14 int-TSS are duplicates and are also annotated as alt-TSS
features <- rtracklayer::import("input/20210217_syne_onlyUnique_withFeat.gff3")
TUs <- rtracklayer::import("input/Kopf_4091_TUs_combined.gff3")
# import PSS and TSS identified in TIER-seq analysis
TIERseq_PSS_TSS <- rtracklayer::import("input/TSS_PSS_rneAnalysis_all.gff")
```

# Identification and characterization of TSS and PSS sites

## Identification of TSS and PSS using edgeR and DESeq2

Input are tables of PSS and TSS 5' end counts prepared using a workflow on usegalaxy.eu and a python script. Sequencing data was created from libraries prepared similar to the protocol described in @Innocenti_2015 (tagRNA-Seq).

```{r read-input}
PSS_raw <- read.delim("input/PSS_5ends_combined_5sensing.txt", header=TRUE, row.names=1)
names(PSS_raw) <- paste(names(PSS_raw), "_PSS", sep="")
TSS_raw <- read.delim("input/TSS_5ends_combined_5sensing.txt", header=TRUE, row.names=1)
names(TSS_raw) <- paste(names(TSS_raw), "_TSS", sep="")

# merge PSS and TSS to merged_raw
merged_raw <- merge(PSS_raw, TSS_raw, by="row.names")
row.names(merged_raw) <- merged_raw$Row.names
merged_raw$Row.names <- NULL
rm(PSS_raw)
rm(TSS_raw)
```

When taking into account lowly populated sites, DESeq2 dispersion estimates become over-fitted. Hence, edgeR::filterByExpression() is used as a pre-processing step before further DESeq2 analyses.

```{r edgeR-filter}
group=c(rep("dWT_PSS", 3), rep("WT_PSS", 3), rep("TV_PSS", 2), rep("dWT_TSS", 3), rep("WT_TSS", 3), rep("TV_TSS", 2))
y <- DGEList(counts=merged_raw, group=group)
nrow(y)
keep <- filterByExpr(y)
y <- y[keep, ,keep.lib.size=FALSE] #reduces from 7,894,038 positions to 15,721
nrow(y)

merged_filtered <- merged_raw[row.names(y$counts),]
nrow(merged_filtered)
rm(merged_raw)
```

Since TSS libraries are generally larger than PSS libraries, size factors are determined separately for the different data set types. Size factors for TSS and PSS correlate quite well for different samples.

```{r estimate-size-factors}
coldata_PSS <- read.csv("input/colData_PSS.csv", row.names=1)
coldata_TSS <- read.csv("input/colData_TSS.csv", row.names=1)

# create DESeq2 data object
ddsMat_PSS <- DESeqDataSetFromMatrix(countData = merged_filtered[,1:8],
                                 colData = coldata_PSS,
                                 design = ~ strain)
ddsMat_TSS <- DESeqDataSetFromMatrix(countData = merged_filtered[,9:16],
                                 colData = coldata_TSS,
                                 design = ~ strain)

# run DESeq
ddsMat_PSS <- estimateSizeFactors(ddsMat_PSS) 
ddsMat_TSS <- estimateSizeFactors(ddsMat_TSS) 

# factors needed for creation of .grp file for multireads data
write.csv(data.frame(factor=ddsMat_PSS$sizeFactor), file="output/PSS_sizeFactors.csv")
write.csv(data.frame(factor=ddsMat_TSS$sizeFactor), file="output/TSS_sizeFactors.csv")

sizeFact <- c(ddsMat_PSS$sizeFactor, ddsMat_TSS$sizeFactor)
plot(sizeFact[1:8], sizeFact[9:16], xlab="Size Factors PSS", ylab="Size Factors TSS")
```

If .grp were not yet created, create .grp files by setting if() to TRUE (! takes some time !):

```{r}
if(FALSE){
PSS_raw <- read.delim("input/PSS_5ends_combined_5sensing.txt", header=TRUE, row.names=1)
names(PSS_raw) <- paste(names(PSS_raw), "_PSS", sep="")

ddsMat_PSS_2 <- DESeqDataSetFromMatrix(countData = PSS_raw,
                                 colData = coldata_PSS,
                                 design = ~ strain)
ddsMat_PSS_2$sizeFactor <- ddsMat_PSS$sizeFactor

PSS_norm_counts <- counts(ddsMat_PSS_2, normalized=TRUE)
rm(ddsMat_PSS_2)

grp_File <- data.frame("WT"=apply(PSS_norm_counts[,c("WT1_PSS", "WT2_PSS", "WT3_PSS")],1,mean), "dWT"=apply(PSS_norm_counts[,c("dWT1_PSS", "dWT2_PSS", "dWT3_PSS")],1,mean), "TV"=apply(PSS_norm_counts[,c("TV1_PSS", "TV2_PSS")],1,mean))
 
grp_File$seqname <- rep(NA, length(grp_File$WT))
seqnames <- c("BA000022.2", "AP004310.1", "AP004311.1", "AP004312.1", "AP006585.1")
for(i in seqnames){
  grp_File[which(grepl(i, row.names(grp_File))),]$seqname <- i
}
grp_File$strand <- rep(NA, length(grp_File$WT))
for(i in c("plus", "minus")){
  grp_File[which(grepl(i, row.names(grp_File))),]$strand <- i
}

for(i in seqnames){
  for(j in c("plus", "minus")){
    tmp <- subset(grp_File, grp_File$seqname==i & grp_File$strand==j)[,c("WT", "dWT", "TV")]
    s=""
    if(j=="plus"){
      s="fw"
    }else{
      s="rev"
   }
    write.table(tmp, file=paste("output/grp/PSS/", i, "_PSS_WT-dWT-TV_", s, ".grp", sep=""), sep="\t", row.names=FALSE, col.names = FALSE)
  }
}
  
}
```

```{r}
if(FALSE){
TSS_raw <- read.delim("input/TSS_5ends_combined_5sensing.txt", header=TRUE, row.names=1)
names(TSS_raw) <- paste(names(TSS_raw), "_TSS", sep="")

ddsMat_TSS_2 <- DESeqDataSetFromMatrix(countData = TSS_raw,
                                 colData = coldata_TSS,
                                 design = ~ strain)
ddsMat_TSS_2$sizeFactor <- ddsMat_TSS$sizeFactor

TSS_norm_counts <- counts(ddsMat_TSS_2, normalized=TRUE)
rm(ddsMat_TSS_2)

grp_File <- data.frame("WT"=apply(TSS_norm_counts[,c("WT1_TSS", "WT2_TSS", "WT3_TSS")],1,mean), "dWT"=apply(TSS_norm_counts[,c("dWT1_TSS", "dWT2_TSS", "dWT3_TSS")],1,mean), "TV"=apply(TSS_norm_counts[,c("TV1_TSS", "TV2_TSS")],1,mean))
 
grp_File$seqname <- rep(NA, length(grp_File$WT))
seqnames <- c("BA000022.2", "AP004310.1", "AP004311.1", "AP004312.1", "AP006585.1")
for(i in seqnames){
  grp_File[which(grepl(i, row.names(grp_File))),]$seqname <- i
}
grp_File$strand <- rep(NA, length(grp_File$WT))
for(i in c("plus", "minus")){
  grp_File[which(grepl(i, row.names(grp_File))),]$strand <- i
}

for(i in seqnames){
  for(j in c("plus", "minus")){
    tmp <- subset(grp_File, grp_File$seqname==i & grp_File$strand==j)[,c("WT", "dWT", "TV")]
    s=""
    if(j=="plus"){
      s="fw"
    }else{
      s="rev"
   }
    write.table(tmp, file=paste("output/grp/TSS/", i, "_TSS_WT-dWT-TV_", s, ".grp", sep=""), sep="\t", row.names=FALSE, col.names = FALSE)
  }
}
  
}
```

DESeq2 is used to determine which positions are enriched in the TSS and PSS libraries, respectively. Size factors determined above are used.

```{r PSSTSS-DESeq2-analysis}
coldata <- read.csv("input/colData_PSS-TSS.csv", row.names=1)

# create DESeq2 data object
ddsMat_PSSTSS <- DESeqDataSetFromMatrix(countData = merged_filtered,
                                 colData = coldata,
                                 design = ~ strain + type)

ddsMat_PSSTSS$sizeFactor <- sizeFact
ddsMat_PSSTSS <- DESeq(ddsMat_PSSTSS)

res_PSSTSS <- results(ddsMat_PSSTSS, contrast=c("type", "PSS", "TSS"))
write.csv(res_PSSTSS[order(res_PSSTSS$padj),], file="output/DESeq2_resultsTables/results_PSS-TSS-copmarisons.csv")
```

As a next stop, a first unfiltered set of potential PSS and TSS positions is created:

```{r PSSTSS-extract-DESeq2-results}
PSS_positions_unfiltered <- row.names(subset(res_PSSTSS, res_PSSTSS$log2FoldChange>0.8 & res_PSSTSS$padj<0.05))
TSS_positions_unfiltered <- row.names(subset(res_PSSTSS, res_PSSTSS$log2FoldChange<(-0.8) & res_PSSTSS$padj<0.05))
```

Create GRanges object for PSS data:

```{r}
PSS_nonReduced_Ranges <- create_GRanges_object(base::strsplit(PSS_positions_unfiltered, "-"), res_PSSTSS[PSS_positions_unfiltered,]$baseMean)
PSS_nonReduced_Ranges$name <- PSS_positions_unfiltered
PSS_nonReduced_Ranges$type <- "PSS"
```

### Diagnostic Plots

```{r}
pdf(file="output/DESeq2_Plots/ddsMat_PSSTSS_DispEsts.pdf", width=4.5, height=4.5)
plotDispEsts(ddsMat_PSSTSS, xlab="Mean of Normalized Counts", ylab="Dispersion")
dev.off()
plotDispEsts(ddsMat_PSSTSS)
```

PSS and TSS data sets are separated on principal component 1.

```{r}
p <- PCA_plot_PSSTSS(ddsMat_PSSTSS, "PSS-TSS")
p
ggsave("output/DESeq2_Plots/ddsMat_PSSTSS_PCA.pdf", plot=p, width=15, height=9, units="cm")

p <- heatmap_plot_PSSTSS(ddsMat_PSSTSS, "PSS-TSS")
p
ggsave("output/DESeq2_Plots/ddsMat_PSSTSS_heatMap.pdf", plot=p, width=15, height=12, units="cm")
```

Comparing PSS and TSS using DESeq2 yields a bimodal log2foldchange distribution. This underlines that PSS and TSS are quite well discernible using the chosen approach. This log2FC distribution is also observable in the non-normalized count data. This is further corroborated by the MAplot and also regarding p-values etc. (see below: Volcano plot and p-value-plot).

```{r}
pdf(file="output/DESeq2_Plots/ddsMat_PSSTSS_hist_log2FC.pdf", width=4.5, height=4.5)
hist(res_PSSTSS$log2FoldChange, breaks=20, main="", xlab="Log2FC(PSS/TSS)", ylab="Frequency")
dev.off()
hist(res_PSSTSS$log2FoldChange, breaks=20, main="DESeq2 Normalization", xlab="Log2FC PSS/TSS", ylab="Frequency")

# non-normalized
log2_all <- log2(apply(merged_filtered[,1:8],1, mean)/apply(merged_filtered[,9:16],1,mean))
hist(log2_all, breaks=20, main="No normalization", xlab="Log2(PSS/TSS)")

p <- MAplot_ggplot(res_PSSTSS, foldchange=0.8, y_axis_label = "Log2 fold-change(PSS/TSS)")
p <- p + scale_colour_manual(values=c("UP"="#4e9879ff", "DOWN"="#9b511fff", "NO"="#d3d3d3ff"))
p
ggsave("output/DESeq2_Plots/ddsMat_PSSTSS_MAplot.pdf",plot=p, width=15, height=12, units="cm")
```

```{r}
res_PSSTSS <- subset(res_PSSTSS, !is.na(res_PSSTSS$padj))

# down: TSS, up: PSS
count_up_down(res_PSSTSS, foldchange=0.8, padjusted=0.05)
p <- volcanoPlot_ggplot(res_PSSTSS, foldchange=0.8, padjusted=0.05) + scale_colour_manual(values=c("UP"="#4e9879ff", "DOWN"="#9b511fff", "NO"="#d3d3d3ff"))
p
ggsave("output/DESeq2_Plots/ddsMat_PSSTSS_VolcanoPlot.pdf", plot=p, width=15, height=12, units="cm")

pdf(file="output/DESeq2_Plots/ddsMat_PSSTSS_pValuePlot.pdf", width=4.5, height=4.5)
pvaluePlot(res_PSSTSS, "Comparison PSS to TSS")
dev.off()
pvaluePlot(res_PSSTSS, "Comparison PSS to TSS")
```

### Filter potential TSS-positions for positions with (TSS-reads)/(transcript-coverage)>0.02 and <2.0

By inspecting the identified TSS, we observed that a high number of false-positive TSS positions are present in highly expressed genes. To control for this, we control for TSS with a ratio (number TSS-reads)/(number transcript reads) above a certain threshold. To determine this cut-off, we manually inspected highly expressed genomic positions such as the 5' UTR of *psbA2*, *ncr0700*, *ssrA* and *CRISPR3*. For instance for *psbA2*, the actual TSS are well established by independent experiments (@sakurai_positive_2012). 2% seemed to be a good cut-off for this control.

Further, we introduced a cut-off to filter against TSS without associated transcription. The used library preparation protocol does not capture sRNAs with a length below 200nt and TSS without accompanying transcription might be TSS of sRNAs. However, we assume a high percentage of TSS which were identified without associated transcription are false positives, e.g. created by reverse transcription artefacts. An example is the second TSS upstream of PsbA2R. The actual TSS of the transcript was determined in @sakurai_positive_2012. We decided to filter out TSS for which the ratio (number TSS-reads)/(number transcript coverage) > 200%.

First, transcript coverage data has to be read in and normalized:

```{r filterTSS-positions}
transcript_coverage <- read.delim("input/transcript_coverage_combined_5sensing.txt", header=TRUE, row.names=1)

group=c(rep("dWT", 3), rep("WT", 3), rep("TV", 2))
y <- DGEList(counts=transcript_coverage, group=group)
nrow(y)
keep <- filterByExpr(y)
y <- y[keep, ,keep.lib.size=FALSE] #reduces from 7,894,038 positions to 4,017,775
nrow(y)

transcript_coverage_filt <- transcript_coverage[row.names(y$counts),]
rm(transcript_coverage) # remove to make space 

coldata <- read.csv("input/colData_transcript.csv", row.names=1)

# create DESeq2 data object
ddsMat_transc <- DESeqDataSetFromMatrix(countData = transcript_coverage_filt,
                                 colData = coldata,
                                 design = ~ strain)

ddsMat_transc <- estimateSizeFactors(ddsMat_transc)
trans_norm <- as.data.frame(counts(ddsMat_transc, normalized=TRUE))
TSS_norm <- as.data.frame(counts(ddsMat_TSS, normalized=TRUE))
```

Do actual filtering and select TSS which are located within a distance of 20nt of annotated TSS by @kopf_2014. Save those TSS combined with the PSS determined as part of this analysis as .gff

```{r}
TSS_trans_ratio_cutoff <- 0.02
upper_TSS_trans_ratio_cutoff <- 2.00
TSS_trans_ratio <- apply(TSS_norm[TSS_positions_unfiltered,],1,mean)/apply(trans_norm[TSS_positions_unfiltered,],1,mean)
TSS_above_cutoff <- subset(TSS_positions_unfiltered, TSS_trans_ratio[TSS_positions_unfiltered]>TSS_trans_ratio_cutoff & TSS_trans_ratio[TSS_positions_unfiltered]<upper_TSS_trans_ratio_cutoff)
TSS_nonReduced_Ranges <- create_GRanges_object(base::strsplit(TSS_above_cutoff, "-"), res_PSSTSS[TSS_above_cutoff,]$baseMean)
TSS_nonReduced_Ranges$name <- TSS_above_cutoff
highly_prob_TSS <- TSS_nonReduced_Ranges[which(countOverlaps(TSS_nonReduced_Ranges, anno_TSS, maxgap=20)>0)]
names_prob_TSS <- highly_prob_TSS$name
length(reduce(highly_prob_TSS))
highly_prob_TSS$type <- "TSS"
save_gff(c(highly_prob_TSS,PSS_nonReduced_Ranges), "output/annoTSS_comparison/gffs/only5sensing/", "TSS_PSS_only5sensing")
```

## Combining TSS and PSS identified here with TSS, PSS from TIER-seq analysis

```{r}
TSS_TIERseq <- subset(TIERseq_PSS_TSS, TIERseq_PSS_TSS$type=="TSS")
PSS_TIERseq <- subset(TIERseq_PSS_TSS, TIERseq_PSS_TSS$type=="PSS")
```

```{r}
PSS_combined <- unique(c(PSS_nonReduced_Ranges, PSS_TIERseq))
length(PSS_combined)
length(PSS_combined)/length(c(PSS_TIERseq,PSS_nonReduced_Ranges))

PSS_combined$strand_ident <- NA
PSS_combined[strand(PSS_combined)=="+",]$strand_ident <- "plus"
PSS_combined[strand(PSS_combined)=="-",]$strand_ident <- "minus"

PSS_positions_combined <- paste(seqnames(PSS_combined), start(PSS_combined), PSS_combined$strand_ident, sep="-")
```

```{r}
TSS_combined <- unique(c(highly_prob_TSS, TSS_TIERseq))
length(TSS_combined)
length(TSS_combined)/length(c(highly_prob_TSS, TSS_TIERseq))

TSS_combined$strand_ident <- NA
TSS_combined[strand(TSS_combined)=="+",]$strand_ident <- "plus"
TSS_combined[strand(TSS_combined)=="-",]$strand_ident <- "minus"

TSS_positions_combined <- paste(seqnames(TSS_combined), start(TSS_combined), TSS_combined$strand_ident, sep="-")
```

```{r}
TSS_combined$type <- "TSS"
PSS_combined$type <- "PSS"
save_gff(c(TSS_combined, PSS_combined), "output/annoTSS_comparison/gffs/combined/", "TSS_PSS_combined")
```

### Compare positions which will be used in analysis with anno-TSS

```{r}
PSS_positions_Ranges <- GenomicRanges::reduce(PSS_combined)
length(PSS_positions_Ranges)
```

```{r}
TSS_positions_Ranges <- GenomicRanges::reduce(TSS_combined)
length(TSS_positions_Ranges)
```

```{r}
p <- ggplot(data=as.data.frame(PSS_positions_Ranges), aes(x=width)) + geom_histogram(fill="darkgray", binwidth=1, color="darkgray") + theme_light() + xlab("Width of reported PSS") + ylab("Number of cases") + scale_x_continuous(breaks=c(1,2,3,4,5,6,7,8,9,10))
p 
ggsave("output/annoTSS_comparison/hist_width_reported-PSS.pdf", plot=p, width=9, height=9, units="cm")

p <- ggplot(data=as.data.frame(TSS_positions_Ranges), aes(x=width)) + geom_histogram(fill="darkgray", binwidth=1, color="darkgray") + theme_light() + xlab("Width of reported TSS") + ylab("Number of cases") + scale_x_continuous(breaks=c(1,2,3,4,5,6,7,8,9,10), limits=c(0,10))
p 
ggsave("output/annoTSS_comparison/hist_width_reported-TSS.pdf", plot=p, width=9, height=9, units="cm")
```

```{r}
# prepare data.frame to count numbers of TSS, PSS overlapping with anno-TSS
df_overlap_TSSPSS <- as.data.frame(cbind(type=c(rep("PSS", 4), rep("TSS",4)), TSS=c(rep(c("start", "alt", "int", "i-start"), 2))))
df_overlap_TSSPSS$number <- NA

## count TSS, PSS overlapping with certain anno-TSS
# overlap of start anno_TSS _without_ TU_type: i with PSS, TSS
df_overlap_TSSPSS[df_overlap_TSSPSS$type=="PSS" & df_overlap_TSSPSS$TSS=="start",3] <- sum(countOverlaps(PSS_positions_Ranges, subset(anno_TSS, anno_TSS$TSS_type=="start" & !grepl("i", anno_TSS$TU_type, fixed = TRUE))))

df_overlap_TSSPSS[df_overlap_TSSPSS$type=="TSS" & df_overlap_TSSPSS$TSS=="start",3] <- sum(countOverlaps(TSS_positions_Ranges, subset(anno_TSS, anno_TSS$TSS_type=="start" & !grepl("i", anno_TSS$TU_type, fixed = TRUE))))

# overlap of start anno_TSS _with only_ TU_type: i with PSS, TSS
df_overlap_TSSPSS[df_overlap_TSSPSS$type=="PSS" & df_overlap_TSSPSS$TSS=="i-start",3] <- sum(countOverlaps(PSS_positions_Ranges, subset(anno_TSS, anno_TSS$TSS_type=="start" & grepl("i", anno_TSS$TU_type, fixed = TRUE))))

df_overlap_TSSPSS[df_overlap_TSSPSS$type=="TSS" & df_overlap_TSSPSS$TSS=="i-start",3] <- sum(countOverlaps(TSS_positions_Ranges, subset(anno_TSS, anno_TSS$TSS_type=="start" & grepl("i", anno_TSS$TU_type, fixed = TRUE))))

# overlap of alt anno_TSS with PSS, TSS
df_overlap_TSSPSS[df_overlap_TSSPSS$type=="PSS" & df_overlap_TSSPSS$TSS=="alt",3] <- sum(countOverlaps(PSS_positions_Ranges, subset(anno_TSS, anno_TSS$TSS_type=="alt")))
df_overlap_TSSPSS[df_overlap_TSSPSS$type=="TSS" & df_overlap_TSSPSS$TSS=="alt",3] <- sum(countOverlaps(TSS_positions_Ranges, subset(anno_TSS, anno_TSS$TSS_type=="alt")))

# overlap of int anno_TSS with PSS, TSS
df_overlap_TSSPSS[df_overlap_TSSPSS$type=="PSS" & df_overlap_TSSPSS$TSS=="int",3] <- sum(countOverlaps(PSS_positions_Ranges, subset(anno_TSS, anno_TSS$TSS_type=="int")))
df_overlap_TSSPSS[df_overlap_TSSPSS$type=="TSS" & df_overlap_TSSPSS$TSS=="int",3] <- sum(countOverlaps(TSS_positions_Ranges, subset(anno_TSS, anno_TSS$TSS_type=="int")))

#control
sum((countOverlaps(PSS_positions_Ranges, anno_TSS)>0))
sum(df_overlap_TSSPSS[df_overlap_TSSPSS$type=="PSS",]$number)
sum((countOverlaps(TSS_positions_Ranges,anno_TSS)>0))
sum((countOverlaps(anno_TSS,TSS_positions_Ranges)>0)) # problem: anno_TSS are not unique - some alt and int TSS overlap. 
sum(df_overlap_TSSPSS[df_overlap_TSSPSS$type=="TSS",]$number)
```

The majority of anno-TSS which overlap with PSS are not canonical start TSS, but actual int or alt TSS.

```{r}
p <- ggplot(data=df_overlap_TSSPSS, aes(x=type, y=number, fill=TSS)) + geom_bar(position="fill", stat="identity") + theme_light()+ xlab("") + ylab("Percentage") + scale_fill_grey(start = .2, end = .9)
p
ggsave(filename = "output/annoTSS_comparison/barplot_TSS-PSS-KopfTSS.pdf", plot = p, width = 7, height = 7, units = "cm")
write.csv(as.data.frame(PSS_positions_Ranges[which(countOverlaps(PSS_positions_Ranges, anno_TSS)>0)]), file="output/annoTSS_comparison/PSS_overlapping_annoTSS.csv")
```

Calculate how many PSS overlap with annotated regions:

```{r}
sum(countOverlaps(PSS_positions_Ranges,TUs)>0|countOverlaps(PSS_positions_Ranges,features)>0)/length(PSS_positions_Ranges)
```

Calculate number and percentage of TUs and CDS which are overlapped by captured PSS:

```{r}
sum(countOverlaps(TUs,PSS_positions_Ranges)>0)
sum(countOverlaps(TUs,PSS_positions_Ranges)>0)/length(TUs)
sum(countOverlaps(features,PSS_positions_Ranges)>0)
sum(countOverlaps(features,PSS_positions_Ranges)>0)/length(features)
```

### Extract DNA sequences upstream of TSS and upstream + downstream of PSS

```{r}
syne_fasta <- readDNAStringSet("input/Synechocystis.fasta", format="fasta")
```

The following chunk of code filters TSS and PSS positions, so that the resulting GRanges objects only encompass TSS/PSS positions which are the most populated in a TSS/PSS region (a stretch of directly adjacent TSS/PSS).

```{r}
TSS_advReduce_Ranges <- advanced_reduce(TSS_nonReduced_Ranges)
PSS_advReduce_Ranges <- advanced_reduce(PSS_nonReduced_Ranges)
```

Actually interesting stuff is only happening in region -20 nt upstream: Hence, only extract this region.

```{r}
TSS_DNA_sequences_40nt <- extract_DNA_sequences(TSS_advReduce_Ranges, syne_fasta, len=20, only_upstream=TRUE)
PSS_DNA_sequences <- extract_DNA_sequences(PSS_advReduce_Ranges, syne_fasta, len=10, only_upstream=FALSE)

writeXStringSet(TSS_DNA_sequences_40nt, "output/annoTSS_comparison/weblogos/allTSS_20nt_forWeblogo.fasta", append=FALSE,
                compress=FALSE, compression_level=NA, format="fasta")
writeXStringSet(PSS_DNA_sequences, "output/annoTSS_comparison/weblogos/PSS_10nt_forWeblogo_upAndDownstream.fasta", append=FALSE,
                compress=FALSE, compression_level=NA, format="fasta")
```

run createWeblogos_10-20nt_DNA.txt for creation of sequence logos

# Use newly identified sets of TSS and PSS for identifying differentially expressed positions between WT, *rne*(WT) and *rne*(5p)

```{r read-in-PSS-TSS-perform-DESeq2}
PSS_raw <- read.delim("input/PSS_5ends_combined_5sensing.txt", header=TRUE, row.names=1)
PSS_use <- PSS_raw[PSS_positions_combined,]

TSS_raw <- read.delim("input/TSS_5ends_combined_5sensing.txt", header=TRUE, row.names=1)
TSS_use <- TSS_raw[TSS_positions_combined,]

rm(PSS_raw)
rm(TSS_raw)

coldata <- read.csv("input/colData.csv", row.names=1)

ddsMat_PSS <- DESeqDataSetFromMatrix(countData = PSS_use,
                                 colData = coldata,
                                 design = ~ strain)

ddsMat_TSS <- DESeqDataSetFromMatrix(countData = TSS_use,
                                 colData = coldata,
                                 design = ~ strain)

ddsMat_PSS <- DESeq(ddsMat_PSS) 
ddsMat_TSS <- DESeq(ddsMat_TSS) 
```

```{r export-normlized-readFiles}
write.csv(data.frame(counts(ddsMat_PSS, normalized=TRUE)), file="output/PSS_normalizedCounts.csv")
write.csv(data.frame(counts(ddsMat_TSS, normalized=TRUE)), file="output/TSS_normalizedCounts.csv")
```

## Diagnostic Plots

```{r}
pdf(file="output/DESeq2_Plots/ddsMat_PSS_DispEsts.pdf", width=4.5, height=4.5)
plotDispEsts(ddsMat_PSS, main="PSS comparison", xlab="Mean of Normalized Counts", ylab="Dispersion")
dev.off()
pdf(file="output/DESeq2_Plots/ddsMat_TSS_DispEsts.pdf", width=4.5, height=4.5)
plotDispEsts(ddsMat_TSS, main="TSS comparison", xlab="Mean of Normalized Counts", ylab="Dispersion")
dev.off()
plotDispEsts(ddsMat_PSS, main="PSS comparison", xlab="Mean of Normalized Counts", ylab="Dispersion")
plotDispEsts(ddsMat_TSS, main="TSS comparison", xlab="Mean of Normalized Counts", ylab="Dispersion")
```

```{r}
p <- PCA_plot(ddsMat_PSS, "PSS")
p 
ggsave("output/DESeq2_Plots/ddsMat_PSS_PCA.pdf", plot=p, width=9, height=9, units="cm")

p <- PCA_plot(ddsMat_TSS, "TSS")
p
ggsave("output/DESeq2_Plots/ddsMat_TSS_PCA.pdf", plot=p, width=9, height=9, units="cm")

p <- heatmap_plot(ddsMat_PSS, "PSS")
p
ggsave("output/DESeq2_Plots/ddsMat_PSS_heatMap.pdf", plot=p, width=15, height=12, units="cm")

p <- heatmap_plot(ddsMat_TSS, "TSS")
p
ggsave("output/DESeq2_Plots/ddsMat_TSS_heatMap.pdf", plot=p, width=15, height=12, units="cm")
```

## Extract Results

```{r}
# extract results
PSS_result_dWT_WT <- results(ddsMat_PSS, contrast=c("strain", "dWT", "WT")) # dWT/WT -> higher in dWT: higher log2FC
write.csv(PSS_result_dWT_WT[order(PSS_result_dWT_WT$padj),], file="output/DESeq2_resultsTables/results_PSS-dWT-WT.csv")

PSS_result_dWT_TV <- results(ddsMat_PSS, contrast=c("strain", "dWT", "TV")) # dWT/TV -> higher in dWT: higher log2FC
write.csv(PSS_result_dWT_TV[order(PSS_result_dWT_TV$padj),], file="output/DESeq2_resultsTables/results_PSS-dWT-TV.csv")

PSS_result_WT_TV <- results(ddsMat_PSS, contrast=c("strain", "WT", "TV")) # WT/TV -> higher in WT: higher log2FC
write.csv(PSS_result_WT_TV[order(PSS_result_WT_TV$padj),], file="output/DESeq2_resultsTables/results_PSS-WT-TV.csv")

TSS_result_dWT_WT <- results(ddsMat_TSS, contrast=c("strain", "dWT", "WT")) # dWT/WT -> higher in dWT: higher log2FC
write.csv(TSS_result_dWT_WT[order(TSS_result_dWT_WT$padj),], file="output/DESeq2_resultsTables/results_TSS-dWT-WT.csv")

TSS_result_dWT_TV <- results(ddsMat_TSS, contrast=c("strain", "dWT", "TV")) # dWT/TV -> higher in dWT: higher log2FC
write.csv(TSS_result_dWT_TV[order(TSS_result_dWT_TV$padj),], file="output/DESeq2_resultsTables/results_TSS-dWT-TV.csv")

TSS_result_WT_TV <- results(ddsMat_TSS, contrast=c("strain", "WT", "TV")) # WT/TV -> higher in WT: higher log2FC
write.csv(TSS_result_WT_TV[order(TSS_result_WT_TV$padj),], file="output/DESeq2_resultsTables/results_TSS-WT-TV.csv")
```

Annotate peak regions

```{r}
indices_plus <- which(strand(PSS_nonReduced_Ranges)=="+")
indices_minus <- which(strand(PSS_nonReduced_Ranges)=="-") 
PSS_names <- c()
PSS_names[indices_plus] <- paste(seqnames(PSS_nonReduced_Ranges[indices_plus]),start(PSS_nonReduced_Ranges[indices_plus]),"plus",sep="-")
PSS_names[indices_minus] <- paste(seqnames(PSS_nonReduced_Ranges[indices_minus]),start(PSS_nonReduced_Ranges[indices_minus]),"minus",sep="-")
rm(indices_plus)
rm(indices_minus)
PSS_nonReduced_Ranges$names <- PSS_names
PSS_nonReduced_Ranges$featuresOverlap <- rep("", length(PSS_nonReduced_Ranges))
PSS_nonReduced_Ranges$TU_overlap <- rep("", length(PSS_nonReduced_Ranges))
for(i in 1:length(PSS_nonReduced_Ranges)){
  PSS_nonReduced_Ranges$featuresOverlap[i] <- paste(features[which(countOverlaps(features,PSS_nonReduced_Ranges[i])>0)]$locus_tag,collapse=",")
  PSS_nonReduced_Ranges$TU_overlap[i] <- paste(TUs[which(countOverlaps(TUs,PSS_nonReduced_Ranges[i])>0)]$index,collapse=",")
}
```

```{r}
# create tables with annotation: which features and TUs are overlapping with PSS?
df_PSS_nonRed_Ranges <- as.data.frame(PSS_nonReduced_Ranges)
row.names(df_PSS_nonRed_Ranges) <- df_PSS_nonRed_Ranges$names

# PSS result dWT WT
PSS_result_dWT_WT_annot <- rownames_to_column(as.data.frame(PSS_result_dWT_WT[order(PSS_result_dWT_WT$padj),]))
PSS_result_dWT_WT_annot$CDS <- df_PSS_nonRed_Ranges[PSS_result_dWT_WT_annot$rowname,]$featuresOverlap
PSS_result_dWT_WT_annot$TUs <- df_PSS_nonRed_Ranges[PSS_result_dWT_WT_annot$rowname,]$TU_overlap
PSS_result_dWT_WT_annot <- PSS_result_dWT_WT_annot[,c(8,9,1,2:7)]
write_tsv(PSS_result_dWT_WT_annot, "output/DESeq2_resultsTables/results_dWT_WT_annotated.tsv")

# PSS result dWT TV
PSS_result_dWT_TV_annot <- rownames_to_column(as.data.frame(PSS_result_dWT_TV[order(PSS_result_dWT_TV$padj),]))
PSS_result_dWT_TV_annot$CDS <- df_PSS_nonRed_Ranges[PSS_result_dWT_TV_annot$rowname,]$featuresOverlap
PSS_result_dWT_TV_annot$TUs <- df_PSS_nonRed_Ranges[PSS_result_dWT_TV_annot$rowname,]$TU_overlap
PSS_result_dWT_TV_annot <- PSS_result_dWT_TV_annot[,c(8,9,1,2:7)]
write_tsv(PSS_result_dWT_TV_annot, "output/DESeq2_resultsTables/results_dWT-TV_annotated.tsv")

# PSS result WT, TV
PSS_result_WT_TV_annot <- rownames_to_column(as.data.frame(PSS_result_WT_TV[order(PSS_result_WT_TV$padj),]))
PSS_result_WT_TV_annot$CDS <- df_PSS_nonRed_Ranges[PSS_result_WT_TV_annot$rowname,]$featuresOverlap
PSS_result_WT_TV_annot$TUs <- df_PSS_nonRed_Ranges[PSS_result_WT_TV_annot$rowname,]$TU_overlap
PSS_result_WT_TV_annot <- PSS_result_WT_TV_annot[,c(8,9,1,2:7)]
write_tsv(PSS_result_WT_TV_annot, "output/DESeq2_resultsTables/results_PSS-WT-TV_annotated.tsv")
```

Run in respective Directory (output/DESeq2_resultsTables/)
python    changeAnnotation_DESeq2.py results_dWT_WT_annotated.tsv results_dWT_WT_annotated-2.tsv
python    changeAnnotation_DESeq2.py results_dWT-TV_annotated.tsv results_dWT-TV_annotated-2.tsv
python    changeAnnotation_DESeq2.py results_PSS-WT-TV_annotated.tsv results_PSS-WT-TV_annotated-2.tsv

```{r, fig.wide = TRUE}
pdf(file="output/DESeq2_Plots/ddsMat_PSS-dWT-WT_pValuePlot.pdf", width=4.5, height=4.5)
pvaluePlot(PSS_result_dWT_WT, "PSS dWT WT")
dev.off()
pdf(file="output/DESeq2_Plots/ddsMat_PSS-dWT-TV_pValuePlot.pdf", width=4.5, height=4.5)
pvaluePlot(PSS_result_dWT_TV, "PSS dWT dTV")
dev.off()
pdf(file="output/DESeq2_Plots/ddsMat_dWT-WT_pValuePlot.pdf", width=4.5, height=4.5)
pvaluePlot(TSS_result_dWT_WT, "TSS dWT WT")
dev.off()
pdf(file="output/DESeq2_Plots/ddsMat_TSS-dWT-TV_pValuePlot.pdf", width=4.5, height=4.5)
pvaluePlot(TSS_result_dWT_TV, "TSS dWT TV")
dev.off()
pvaluePlot(PSS_result_dWT_WT, "PSS dWT WT")
pvaluePlot(PSS_result_dWT_TV, "PSS dWT dTV")
pvaluePlot(TSS_result_dWT_WT, "TSS dWT WT")
pvaluePlot(TSS_result_dWT_TV, "TSS dWT TV")
```

Filter out PSS below filter level of results(). For these, p.adj is set to NA - hence: remove positions at which p.adj==NA

```{r}
PSS_result_dWT_WT <- subset(PSS_result_dWT_WT, !is.na(PSS_result_dWT_WT$padj))
PSS_result_dWT_TV <- subset(PSS_result_dWT_TV, !is.na(PSS_result_dWT_TV$padj))
PSS_result_WT_TV <- subset(PSS_result_WT_TV, !is.na(PSS_result_WT_TV$padj))
TSS_result_dWT_WT <- subset(TSS_result_dWT_WT, !is.na(TSS_result_dWT_WT$padj))
TSS_result_dWT_TV <- subset(TSS_result_dWT_TV, !is.na(TSS_result_dWT_TV$padj))
TSS_result_WT_TV <- subset(TSS_result_WT_TV, !is.na(TSS_result_WT_TV$padj))
```

### PSS dWT WT 

```{r, fig.wide = TRUE}
count_up_down(PSS_result_dWT_WT, foldchange=1, padjusted=0.05)

p <- volcanoPlot_ggplot(as.data.frame(PSS_result_dWT_WT), foldchange=1, padjusted=0.05) + scale_colour_manual(values=c("DOWN"="#000000ff", "UP"="#005a96ff", "NO"="#d3d3d3ff"))
p
ggsave("output/DESeq2_Plots/ddsMat_PSS-0h_VolcanoPlot.pdf", plot=p, width=15, height=12, units="cm")

p <- MAplot_ggplot(PSS_result_dWT_WT, foldchange=1.0, y_axis_label = "Log2 fold-change(rne(WT)/WT)") + scale_colour_manual(values=c("DOWN"="#000000ff", "UP"="#005a96ff", "NO"="#d3d3d3ff"))
p
ggsave("output/DESeq2_Plots/ddsMat_PSS-dWT-WT_MAplot.pdf",plot=p, width=15, height=12, units="cm")
```

### PSS dWT-TV

```{r, fig.wide = TRUE}
count_up_down(PSS_result_dWT_TV, foldchange=1, padjusted=0.05)

p <- volcanoPlot_ggplot(as.data.frame(PSS_result_dWT_TV), foldchange=1, padjusted=0.05) + scale_colour_manual(values=c("DOWN"="#e69f00ff", "UP"="#005a96ff", "NO"="#d3d3d3ff"))
p
ggsave("output/DESeq2_Plots/ddsMat_PSS-dWT-TV_VolcanoPlot.pdf", plot=p, width=15, height=12, units="cm")

p <- MAplot_ggplot(PSS_result_dWT_TV, foldchange=1.0, y_axis_label = "Log2 fold-change(rne(WT)/rne(5p))") + scale_colour_manual(values=c("DOWN"="#e69f00ff", "UP"="#005a96ff", "NO"="#d3d3d3ff"))# + ylim(-5,+5)
p
ggsave("output/DESeq2_Plots/ddsMat_PSS-1h_MAplot.pdf",plot=p, width=15, height=12, units="cm")
```

### PSS WT-TV

```{r}
count_up_down(PSS_result_WT_TV, foldchange = 1, padjusted = 0.05)
  
p <- MAplot_ggplot(PSS_result_WT_TV, foldchange=1.0, y_axis_label = "Log2 fold-change(WT/rne(5p))") + scale_colour_manual(values=c("DOWN"="#e69f00ff", "UP"="#000000ff", "NO"="#d3d3d3ff"))# + ylim(-5,+5)
p
ggsave("output/DESeq2_Plots/ddsMat_PSS-WT-TV_MAplot.pdf",plot=p, width=15, height=12, units="cm")
```

### TSS dWT WT 

```{r, fig.wide = TRUE}
count_up_down(TSS_result_dWT_WT, foldchange=1, padjusted=0.05)

p <- volcanoPlot_ggplot(as.data.frame(TSS_result_dWT_WT), foldchange=1, padjusted=0.05) + scale_colour_manual(values=c("DOWN"="#000000ff", "UP"="#005a96ff", "NO"="#d3d3d3ff"))
p
ggsave("output/DESeq2_Plots/ddsMat_TSS-0h_VolcanoPlot.pdf", plot=p, width=15, height=12, units="cm")

p <- MAplot_ggplot(TSS_result_dWT_WT, foldchange=1.0, y_axis_label = "Log2 fold-change(rne(WT)/WT)") + scale_colour_manual(values=c("DOWN"="#000000ff", "UP"="#005a96ff", "NO"="#d3d3d3ff"))
p
ggsave("output/DESeq2_Plots/ddsMat_TSS-dWT-WT_MAplot.pdf",plot=p, width=15, height=12, units="cm")
```

### TSS dWT-TV

```{r, fig.wide = TRUE}
count_up_down(TSS_result_dWT_TV, foldchange=1, padjusted=0.05)

p <- volcanoPlot_ggplot(as.data.frame(TSS_result_dWT_TV), foldchange=1, padjusted=0.05) + scale_colour_manual(values=c("DOWN"="#e69f00ff", "UP"="#005a96ff", "NO"="#d3d3d3ff"))
p
ggsave("output/DESeq2_Plots/ddsMat_TSS-dWT-TV_VolcanoPlot.pdf", plot=p, width=15, height=12, units="cm")

p <- MAplot_ggplot(TSS_result_dWT_TV, foldchange=1.0, y_axis_label = "Log2 fold-change(rne(WT)/rne(5p))") + scale_colour_manual(values=c("DOWN"="#e69f00ff", "UP"="#005a96ff", "NO"="#d3d3d3ff"))# + ylim(-5,+5)
p
ggsave("output/DESeq2_Plots/ddsMat_TSS-1h_MAplot.pdf",plot=p, width=15, height=12, units="cm")
```

### TSS WT-TV

```{r}
count_up_down(TSS_result_WT_TV, foldchange = 1, padjusted = 0.05)
  
p <- MAplot_ggplot(TSS_result_WT_TV, foldchange=1.0, y_axis_label = "Log2 fold-change(WT/rne(5p))") + scale_colour_manual(values=c("DOWN"="#e69f00ff", "UP"="#000000ff", "NO"="#d3d3d3ff"))# + ylim(-5,+5)
p
ggsave("output/DESeq2_Plots/ddsMat_TSS-WT-TV_MAplot.pdf",plot=p, width=15, height=12, units="cm")
```

## Test if 5'-P / 5'-PPP ratio changes at TSS positions

```{r}
TSSPSS_at_TSSpositions <- counts(ddsMat_PSSTSS, normalize=FALSE)[names_prob_TSS,] # normalize= TRUE/FALSE: should not make difference, but decided to use FALSE since should introduce less bias

# calculate ratios
dWT1_ratio=TSSPSS_at_TSSpositions[,"dWT1_PSS"]/TSSPSS_at_TSSpositions[,"dWT1_TSS"]
dWT2_ratio=TSSPSS_at_TSSpositions[,"dWT2_PSS"]/TSSPSS_at_TSSpositions[,"dWT2_TSS"]
dWT3_ratio=TSSPSS_at_TSSpositions[,"dWT3_PSS"]/TSSPSS_at_TSSpositions[,"dWT3_TSS"]
WT1_ratio=TSSPSS_at_TSSpositions[,"WT1_PSS"]/TSSPSS_at_TSSpositions[,"WT1_TSS"]
WT2_ratio=TSSPSS_at_TSSpositions[,"WT2_PSS"]/TSSPSS_at_TSSpositions[,"WT2_TSS"]
WT3_ratio=TSSPSS_at_TSSpositions[,"WT3_PSS"]/TSSPSS_at_TSSpositions[,"WT3_TSS"]
TV1_ratio=TSSPSS_at_TSSpositions[,"TV1_PSS"]/TSSPSS_at_TSSpositions[,"TV1_TSS"]
TV2_ratio=TSSPSS_at_TSSpositions[,"TV2_PSS"]/TSSPSS_at_TSSpositions[,"TV2_TSS"]
```

```{r}
# create df for plotting
df_TSSPSS_ratio <- data.frame(sample=c(rep("dWT1", length(names_prob_TSS)),rep("dWT2", length(names_prob_TSS)),rep("dWT3", length(names_prob_TSS)),rep("WT1", length(names_prob_TSS)),rep("WT2", length(names_prob_TSS)),rep("WT3", length(names_prob_TSS)),rep("TV1", length(names_prob_TSS)),rep("TV2", length(names_prob_TSS))), type=c(rep("rne(WT)", 3*length(names_prob_TSS)), rep("WT", 3*length(names_prob_TSS)), rep("rne(5p)", 2*length(names_prob_TSS))), TSSPSS_ratio <- c(dWT1_ratio, dWT2_ratio, dWT3_ratio, WT1_ratio, WT2_ratio, WT3_ratio, TV1_ratio, TV2_ratio))
```

```{r}
p <- ggplot(data=df_TSSPSS_ratio, aes(x=sample, y=TSSPSS_ratio, fill=type)) + geom_violin() +
  geom_boxplot(width=0.1, color="grey", alpha=0.2, outlier.shape=NA, show.legend = FALSE) +
  scale_fill_viridis(discrete=TRUE, alpha=0.6, option="A") +
  theme_light() +
  labs(fill="", y="PSS/TSS at TSS positions", x="")
p
```

```{r}
df_TSSPSS_ratio_2 <- subset(df_TSSPSS_ratio, !is.na(df_TSSPSS_ratio$TSSPSS_ratio) & !is.infinite(df_TSSPSS_ratio$TSSPSS_ratio))
df_TSSPSS_ratio_2$TSSPSS_ratio <- df_TSSPSS_ratio_2$TSSPSS_ratio + 0.0001
df_TSSPSS_ratio_2$sample <- factor(df_TSSPSS_ratio_2$sample, levels=c("WT1", "WT2", "WT3", "dWT1", "dWT2", "dWT3", "TV1", "TV2"))
p <- ggplot(data=df_TSSPSS_ratio_2, aes(x=sample, y=TSSPSS_ratio, fill=type)) + geom_violin() +
  geom_boxplot(width=0.1, color="grey", alpha=0.2, outlier.shape=NA, show.legend = FALSE) +
  scale_fill_viridis(discrete=TRUE, alpha=0.6, option="A") +
  theme_light() +
  labs(fill="", y="PSS/TSS at TSS positions", x="") + scale_y_continuous(trans="log10", limits=c(NA,10), breaks=c(0,0.01,0.1,1,10))
p
ggsave("output/PSS-TSS-ratios_TSSpositions.pdf",plot=p, width=15, height=12, units="cm")
```

```{r, echo=FALSE}
save.image(file = "DESeq2_analyses_PSS-TSS.RData")
```
```{r, echo=FALSE}
#load("DESeq2_analyses_PSS-TSS.RData")
```

# Exploratory data analysis

## Extract Peak Positions and create GRanges objects

advanced_reduce_withBaseMeans() merges adjacent PSS positions. In a second step, peaks which are wider than 1nt are reduced to a 1nt wide position according to the baseMeans of the peaks - the most highly populated position is given. PSS_Ranges_WT are peaks which are higher in *rne*(WT), PSS_Ranges_TV peaks which are higher in *rne*(5p). Since there are so few peaks differentially populated in the comparison between *rne*(WT) and WT, these two sets of peaks will not be analysed more specifically.

### For all positions

```{r}
PSS_Ranges_WT <- advanced_reduce_withBaseMeans(create_GRanges_object_from_resObject(PSS_result_dWT_TV, foldchange=1, padjusted=0.05))
PSS_Ranges_TV <- advanced_reduce_withBaseMeans(create_GRanges_object_from_resObject(PSS_result_dWT_TV, foldchange=(-1), padjusted=0.05, up=FALSE))
PSS_Ranges <- c(PSS_Ranges_WT, PSS_Ranges_TV)

PSS_Ranges_dWTtodWT <- advanced_reduce_withBaseMeans(create_GRanges_object_from_resObject(PSS_result_dWT_WT, foldchange=1, padjusted=0.05))
PSS_Ranges_WTtodWT <- advanced_reduce_withBaseMeans(create_GRanges_object_from_resObject(PSS_result_dWT_WT, foldchange=(-1), padjusted=0.05, up=FALSE))
```

## Extract data for Weblogo

```{r}
peaks_all <- extract_RNA_sequences(PSS_Ranges, syne_fasta, 5)
peaks_WT <- extract_RNA_sequences(PSS_Ranges_WT, syne_fasta, 5)
peaks_TV <- extract_RNA_sequences(PSS_Ranges_TV, syne_fasta, 5)

writeXStringSet(peaks_all, "output/rneWT_rne5p_Weblogo/all_peaks_5upDownstream.fasta", append=FALSE,
                compress=FALSE, compression_level=NA, format="fasta")
writeXStringSet(peaks_WT, "output/rneWT_rne5p_Weblogo/peaks_WT_5upDownstream.fasta", append=FALSE,
                compress=FALSE, compression_level=NA, format="fasta")
writeXStringSet(peaks_TV, "output/rneWT_rne5p_Weblogo/peaks_TV_5upDownstream.fasta", append=FALSE,
                compress=FALSE, compression_level=NA, format="fasta")

sum((apply(oligonucleotideFrequency(syne_fasta, width=1), 2, sum)/sum(apply(oligonucleotideFrequency(syne_fasta, width=1),2,sum)))[2:3]) # get GC-content for weblogo
```

run createWebLogos.txt for creation of sequence logos

## Analyse overlap with chromosome/plasmids

Prepare data frames for the plots and count how many PSS are overlapping with which sequence and with how many of the respective features:

```{r}
# prepare data.frame for barplot
sequences <- names(syne_fasta)
updown <- c(rep("rne(WT)",length(sequences)), rep("rne(5p)",length(sequences)))
df_PSS_sequence_barplot <- data.frame(cbind(sequence=sequences, updown=updown))
df_PSS_sequence_barplot$updown <- factor(df_PSS_sequence_barplot$updown, levels=c("rne(WT)", "rne(5p)"))
df_PSS_sequence_barplot$x_labels <- NA
df_PSS_sequence_barplot[df_PSS_sequence_barplot$sequence=="BA000022.2",]$x_labels <- "Chr"
df_PSS_sequence_barplot[df_PSS_sequence_barplot$sequence=="AP004311.1",]$x_labels <- "pSYSA"
df_PSS_sequence_barplot[df_PSS_sequence_barplot$sequence=="AP004312.1",]$x_labels <- "pSYSG"
df_PSS_sequence_barplot[df_PSS_sequence_barplot$sequence=="AP004310.1",]$x_labels <- "pSYSM"
df_PSS_sequence_barplot[df_PSS_sequence_barplot$sequence=="AP006585.1",]$x_labels <- "pSYSX"
df_PSS_sequence_barplot$x_labels <- factor(df_PSS_sequence_barplot$x_labels, levels=c("Chr", "pSYSA", "pSYSG", "pSYSM", "pSYSX"))
df_PSS_sequence_barplot$geno_size <- NA
for(i in df_PSS_sequence_barplot$sequence){
  df_PSS_sequence_barplot[df_PSS_sequence_barplot$sequence==i,]$geno_size <- seqlengths(syne_fasta)[i]
}
df_PSS_sequence_barplot$geno_relative_size <- df_PSS_sequence_barplot$geno_size/sum(seqlengths(syne_fasta))*100
df_PSS_sequence_barplot$number_feat_overlap <- NA
df_PSS_sequence_barplot$number_PSS_overlap <- NA 
df_PSS_sequence_barplot$number_feat_total <- NA
df_PSS_sequence_barplot$PSS_kb <- NA

# prepare data frame for number of overlaps with certain features
df_PSS_sequence_overlap_perKb <- data.frame()

# extract number of overlaps with different sequences and features, both for up- and downregulated PSS positions
for(s in sequences){
  index_up <- which(df_PSS_sequence_barplot$sequence==s & df_PSS_sequence_barplot$updown=="rne(WT)")
  index_down <- which(df_PSS_sequence_barplot$sequence==s & df_PSS_sequence_barplot$updown=="rne(5p)") 
  
  df_PSS_sequence_barplot[index_up,"number_feat_overlap"] <- sum(countOverlaps(subset(features, seqnames(features)==s), PSS_Ranges_WT)>0) # count number of features affected
  df_PSS_sequence_barplot[index_up,"number_PSS_overlap"] <- length(subset(PSS_Ranges_WT, seqnames(PSS_Ranges_WT)==s))
  df_PSS_sequence_barplot[index_up,"PSS_kb"] <- length(subset(PSS_Ranges_WT, seqnames(PSS_Ranges_WT)==s))/(seqlengths(syne_fasta[s])/1000)
    
  df_PSS_sequence_barplot[index_down,"number_feat_overlap"] <- sum(countOverlaps(subset(features, seqnames(features)==s), PSS_Ranges_TV)>0) # count number of features affected
  df_PSS_sequence_barplot[index_down,"number_PSS_overlap"] <- length(subset(PSS_Ranges_TV, seqnames(PSS_Ranges_TV)==s))
  df_PSS_sequence_barplot[index_down,"PSS_kb"] <- length(subset(PSS_Ranges_TV, seqnames(PSS_Ranges_TV)==s))/(seqlengths(syne_fasta[s])/1000)
  
  df_PSS_sequence_barplot[df_PSS_sequence_barplot$sequence==s,"number_feat_total"] <- length(subset(features, seqnames(features)==s))
}

df_PSS_sequence_barplot$perc_feat <- (df_PSS_sequence_barplot$number_feat_overlap/df_PSS_sequence_barplot$number_feat_total)*100
df_PSS_sequence_barplot$perc_all_feat <- NA
df_PSS_sequence_barplot[df_PSS_sequence_barplot$updown=="rne(WT)",]$perc_all_feat <- df_PSS_sequence_barplot[df_PSS_sequence_barplot$updown=="rne(WT)",]$number_PSS_overlap/sum(df_PSS_sequence_barplot[df_PSS_sequence_barplot$updown=="rne(WT)",]$number_PSS_overlap)*100
df_PSS_sequence_barplot[df_PSS_sequence_barplot$updown=="rne(5p)",]$perc_all_feat <- df_PSS_sequence_barplot[df_PSS_sequence_barplot$updown=="rne(5p)",]$number_PSS_overlap/sum(df_PSS_sequence_barplot[df_PSS_sequence_barplot$updown=="rne(5p)",]$number_PSS_overlap)*100
```

```{r}
df_PSS_sequence_barplot
write.csv(df_PSS_sequence_barplot, file="output/overlap_contigs_PSS.csv")
```

```{r}
# Plot: PSS per kb
p <- ggplot(data=df_PSS_sequence_barplot, aes(x=x_labels,y=PSS_kb, fill=updown)) + geom_bar(stat="identity", position="dodge") + theme_light()+ xlab("") + ylab("PSS/kb") + scale_fill_manual(name="", values=c("#005a96ff", "#e69f00ff"), breaks=c("rne(WT)", "rne(5p)"), labels=c("rne(WT)", "rne(5p)"))
p
ggsave(filename = "output/barplots_overlapFeatures/barplot_PSSkb_chr_plasmids.pdf", plot = p, width = 14, height = 7, units = "cm")

# Plot: How many features of a certain kind are overlapped by PSS?
p <- ggplot(data=df_PSS_sequence_barplot, aes(x=x_labels,y=perc_feat, fill=updown)) + geom_bar(stat="identity", position="dodge") + theme_light()+ xlab("") + ylab("Features overlapped by PSS (%)") + scale_fill_manual(name="", values=c("#005a96ff", "#e69f00ff"), breaks=c("rne(WT)", "rne(5p)"), labels=c("rne(WT)", "rne(5p)"))
p
ggsave(filename = "output/barplots_overlapFeatures/barplot_percentageFeatures_chr_plasmids.pdf", plot = p, width = 14, height = 7, units = "cm")

# Plots: How many PSS are localized in which kind of feature?
p <- ggplot(data=df_PSS_sequence_barplot, aes(x=updown,y=number_PSS_overlap, fill=x_labels)) + geom_bar(stat="identity", position="stack") + theme_light()+ xlab("") + ylab("Percentage of all PSS (%)") + scale_fill_brewer(palette="Paired", direction=1)#scale_fill_OkabeIto(name="", order=c(2:8,1))
p
ggsave(filename = "output/barplots_overlapFeatures/barplot_absolute_chromo_plasmids_ofAllPSS.pdf", plot = p, width = 7, height = 7, units = "cm")

p <- ggplot(data=df_PSS_sequence_barplot, aes(x=updown,y=number_PSS_overlap, fill=x_labels)) + geom_bar(stat="identity", position="fill") + theme_light()+ xlab("") + ylab("Number PSS") + scale_fill_brewer(palette="Paired", direction=1)#scale_fill_OkabeIto(name="", order=c(2:8,1))
p
ggsave(filename = "output/barplots_overlapFeatures/barplot_perc_chromo_plasmids_ofAllPSS.pdf", plot = p, width = 7, height = 7, units = "cm")
```

For comparison, plot lengths of different parts of genome:

```{r}
seqlengths_syne <- as.data.frame(seqlengths(syne_fasta))
seqlengths_syne$name <- NA
seqlengths_syne["BA000022.2",]$name <- "Chr"
seqlengths_syne["AP004311.1",]$name <- "pSYSA"
seqlengths_syne["AP004312.1",]$name <- "pSYSG"
seqlengths_syne["AP004310.1",]$name <- "pSYSM"
seqlengths_syne["AP006585.1",]$name <- "pSYSX"
seqlengths_syne$x <- "a"

p <- ggplot(data=seqlengths_syne, aes(x=x, y=seqlengths(syne_fasta), fill=name)) + geom_bar(stat="identity", position="fill") + theme_light()+ xlab("") + ylab("Percentage of total length") + scale_fill_brewer(palette="Paired", direction=1)#scale_fill_OkabeIto(name="", order=c(2:8,1))
p
ggsave(filename = "output/barplots_overlapFeatures/barplot_perc_chromo_plasmids_lengths.pdf", plot = p, width = 6, height = 7, units = "cm")
```

## Analyse overlap with different RNA features and number of overlaps with those features

Prepare data frames for the plots and count how many PSS are overlapping with which features, how many features of a certain type are overlapped by PSS, how many PSS are located in each feature per kb.

```{r}
# prepare data.frame for barplot
types <- rep(c("CDS","5UTR", "3UTR", "tRNA", "rRNA", "ncRNA", "asRNA", "CRISPR", "misc"),3)
updown <- c(rep("up",9), rep("down",9), rep("both",9))
df_PSS_features <- data.frame(cbind(type=types, updown=updown))
df_PSS_features$number_feat_overlap <- NA 
df_PSS_features$number_PSS_overlap <- NA
df_PSS_features$number_total <- NA

# prepare data frame for number of overlaps with certain features
df_PSS_features_overlap_perKb <- data.frame()

# extract number of overlaps with different feature types, both for up- and downregulated PSS positions
types <- c("CDS","5UTR", "3UTR", "tRNA", "rRNA", "ncRNA", "asRNA", "CRISPR", "misc")
for(t in types){
  t_feat <- which(features$type == t)
  
  index_up <- which(df_PSS_features$type==t & df_PSS_features$updown=="up")
  index_down <- which(df_PSS_features$type==t & df_PSS_features$updown=="down") 
  index_both <- which(df_PSS_features$type==t & df_PSS_features$updown=="both") 
  
  df_PSS_features[index_up,"number_feat_overlap"] <- sum(countOverlaps(features[t_feat], PSS_Ranges_WT)>0) # count number of features affected
  df_PSS_features[index_up,"number_PSS_overlap"] <- sum(countOverlaps(PSS_Ranges_WT, features[t_feat])>0) # count where PSS are located
  df_PSS_features[index_down,"number_feat_overlap"] <- sum(countOverlaps(features[t_feat], PSS_Ranges_TV)>0) # count number of features affected
  df_PSS_features[index_down,"number_PSS_overlap"] <- sum(countOverlaps(PSS_Ranges_TV, features[t_feat])>0) # count where PSS are located
  df_PSS_features[index_both,"number_feat_overlap"] <- sum(countOverlaps(features[t_feat], PSS_Ranges_TV)>0 | countOverlaps(features[t_feat], PSS_Ranges_WT)>0) # count number of features affected
  df_PSS_features[index_both,"number_PSS_overlap"] <- sum(countOverlaps(PSS_Ranges_TV, features[t_feat])>0) + sum(countOverlaps(PSS_Ranges_WT, features[t_feat])>0) # count where PSS are located
  
  df_PSS_features[df_PSS_features$type==t,"number_total"] <- length(features[t_feat])
  
  counts_per_kb <- countOverlaps(features[t_feat], PSS_Ranges_WT)/(width(features[t_feat])/1000)
  df_PSS_features_overlap_perKb <- rbind(df_PSS_features_overlap_perKb, data.frame(type=rep(paste(t, "-up", sep=""),length(features[t_feat])), counts_per_kb=counts_per_kb))
  counts_per_kb <- countOverlaps(features[t_feat], PSS_Ranges_TV)/(width(features[t_feat])/1000)
  df_PSS_features_overlap_perKb <- rbind(df_PSS_features_overlap_perKb, data.frame(type=rep(paste(t, "-down", sep=""),length(features[t_feat])), counts_per_kb=counts_per_kb))
}
```

```{r}
df_PSS_features
write.csv(df_PSS_features, file="output/overlap_RNAfeatures_PSS.csv")
```

for TUs:

```{r}
sum(countOverlaps(TUs, PSS_Ranges_WT)>0)
sum(countOverlaps(TUs, PSS_Ranges_TV)>0)
sum((countOverlaps(TUs, PSS_Ranges_WT)|countOverlaps(TUs, PSS_Ranges_TV))>0)
```

### Create bar plots

Do further processing of data frames.

```{r}
df_PSS_features_barplot <- subset(df_PSS_features, df_PSS_features$updown=="up" | df_PSS_features$updown=="down")

total_overlaps_up <- sum(countOverlaps(PSS_Ranges_WT, features)>0)
total_overlaps_down <- sum(countOverlaps(PSS_Ranges_TV, features)>0)

df_PSS_features_barplot[,"number_feat_overlap"] <- as.integer(df_PSS_features_barplot[,"number_feat_overlap"])/as.integer(df_PSS_features_barplot[,"number_total"])*100

# create column  with absolute numbers
df_PSS_features_barplot$number_PSS_overlap_absolute <- NA
df_PSS_features_barplot[df_PSS_features_barplot$updown=="up",]$number_PSS_overlap_absolute <- as.integer(df_PSS_features_barplot[df_PSS_features_barplot$updown=="up","number_PSS_overlap"])
df_PSS_features_barplot[df_PSS_features_barplot$updown=="down",]$number_PSS_overlap_absolute <- as.integer(df_PSS_features_barplot[df_PSS_features_barplot$updown=="down","number_PSS_overlap"])

# calculate percentages
df_PSS_features_barplot[df_PSS_features_barplot$updown=="up","number_PSS_overlap"] <- as.integer(df_PSS_features_barplot[df_PSS_features_barplot$updown=="up","number_PSS_overlap"])/total_overlaps_up *100
df_PSS_features_barplot[df_PSS_features_barplot$updown=="down","number_PSS_overlap"] <- as.integer(df_PSS_features_barplot[df_PSS_features_barplot$updown=="down","number_PSS_overlap"])/total_overlaps_down *100

# rename types (5'UTR instead of 5UTR, 3'UTR instead of 3UTR)
df_PSS_features_barplot[,"type"] <- rep(c("CDS","5'UTR", "3'UTR", "tRNA", "rRNA", "ncRNA", "asRNA", "CRISPR", "misc"),2)

# reduce plot to information I actually care about
df_PSS_features_barplot <- df_PSS_features_barplot[which(!df_PSS_features_barplot$type=="rRNA"),] # rRNAs cannot be counted here, because multireads were excluded from analysis
df_PSS_features_barplot <- df_PSS_features_barplot[which(!df_PSS_features_barplot$type=="misc"),] # misc are actually only genes which are split by plasmid / chromosome beginning and two features (NC-2306445, NC-3547510) where I never figured out what they are. One PSS overlaps with sll8049-1. So I think one can savely ignore those
```

Do actual plotting.

```{r}
# cast type, updown as factors to influence order in which they show up in the plots
df_PSS_features_barplot$type <- factor(df_PSS_features_barplot$type, levels=c("tRNA", "asRNA", "ncRNA", "CRISPR", "3'UTR", "5'UTR", "CDS"))
df_PSS_features_barplot$updown <- c(rep("rne(WT)", 7), rep("rne(5p)",7))
df_PSS_features_barplot$updown <- factor(df_PSS_features_barplot$updown, levels=c("rne(WT)", "rne(5p)"))

# Plot: How many features of a certain kind are overlapped by PSS?
p <- ggplot(data=df_PSS_features_barplot, aes(x=type,y=number_feat_overlap, fill=updown)) + geom_bar(stat="identity", position="dodge") + theme_light()+ xlab("") + ylab("Percentage PSS (%)") + scale_fill_manual(name="", values=c("#005a96ff", "#e69f00ff"), breaks=c("rne(WT)", "rne(5p)"), labels=c("rne(WT)", "rne(5p)"))
p
ggsave(filename = "output/barplots_overlapFeatures/barplot_percentage_of_allThisFeature.pdf", plot = p, width = 14, height = 7, units = "cm")

# Plots: How many PSS are localized in which kind of feature?
p <- ggplot(data=df_PSS_features_barplot, aes(x=updown,y=number_PSS_overlap, fill=type)) + geom_bar(stat="identity", position="stack") + theme_light()+ xlab("") + ylab("Percentage of all PSS (%)") + scale_fill_brewer(palette="Paired", direction=1)#scale_fill_OkabeIto(name="", order=c(2:8,1))
p
ggsave(filename = "output/barplots_overlapFeatures/barplot_percentage_ofAllPSS.pdf", plot = p, width = 7, height = 7, units = "cm")

p <- ggplot(data=df_PSS_features_barplot, aes(x=updown,y=number_PSS_overlap_absolute, fill=type)) + geom_bar(stat="identity", position="stack") + theme_light()+ xlab("") + ylab("Number PSS") + scale_fill_brewer(palette="Paired", direction=1)#scale_fill_OkabeIto(name="", order=c(2:8,1))
p
ggsave(filename = "output/barplots_overlapFeatures/barplot_absolute_ofAllPSS.pdf", plot = p, width = 7, height = 7, units = "cm")
```

### Plots of number PSS per feature

Exclude rRNA, tRNA, misc from plots since not much information in those.

```{r}
df_PSS_features_overlap_perKb <- df_PSS_features_overlap_perKb[which(!df_PSS_features_overlap_perKb$type=="rRNA-up"),]
df_PSS_features_overlap_perKb <- df_PSS_features_overlap_perKb[which(!df_PSS_features_overlap_perKb$type=="rRNA-down"),]
df_PSS_features_overlap_perKb <- df_PSS_features_overlap_perKb[which(!df_PSS_features_overlap_perKb$type=="tRNA-up"),]
df_PSS_features_overlap_perKb <- df_PSS_features_overlap_perKb[which(!df_PSS_features_overlap_perKb$type=="tRNA-down"),]
df_PSS_features_overlap_perKb <- df_PSS_features_overlap_perKb[which(!df_PSS_features_overlap_perKb$type=="misc-up"),]
df_PSS_features_overlap_perKb <- df_PSS_features_overlap_perKb[which(!df_PSS_features_overlap_perKb$type=="misc-down"),]
```

Violin plot for a first overview.

```{r}
p <- ggplot(data=df_PSS_features_overlap_perKb, aes(x=type, y=counts_per_kb, fill=type)) + geom_violin() +
  geom_boxplot(width=0.1, color="grey", alpha=0.2, outlier.shape=NA, show.legend = FALSE) +
  scale_fill_viridis(discrete=TRUE, alpha=0.6, option="A") +
  theme_light() +
  labs(fill="", y="Number of PSS per feature per kb", x="")
p
```

Plot with log-transformation + statistics for all features (add pseudocount of 0.0001 to avoid 0-problem of log-transformation).

```{r}
df_PSS_features_overlap_perKb$type <- as.factor(df_PSS_features_overlap_perKb$type)
magma_colors <- magma(length(levels(df_PSS_features_overlap_perKb$type))/2, alpha = 0.6, begin = 0, end = 1, direction = 1)[c(1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9)]

p <- ggplot(data=df_PSS_features_overlap_perKb, aes(x=type, y=counts_per_kb +0.0001, fill=type)) + 
  geom_boxplot(outlier.shape=NA) + geom_jitter(color="black", size=0.05, alpha=0.9, show.legend=FALSE)+ 
  scale_fill_manual(values=magma_colors)+
  theme_light()+ theme(legend.position = "none") +
  labs(fill="", y="Number of PSS per kb", x="") + scale_y_continuous(trans="log10", limits=c(NA,100), breaks=c(0,2,4,8,16,32,64)) + scale_x_discrete(breaks=c("3UTR-down", "3UTR-up", "5UTR-down", "5UTR-up", "asRNA-down", "asRNA-up", "CDS-down", "CDS-up", "CRISPR-down", "CRISPR-up", "ncRNA-down","ncRNA-up"), labels=c("Ts\n3'UTR", "WT\n3'UTR", "Ts\n5'UTR", "WT\n5'UTR", "Ts\nasRNA", "WT\nasRNA", "Ts\nCDS", "WT\nCDS", "Ts\nCRISPR", "WT\nCRISPR", "Ts\nncRNA", "WT\nncRNA"))
#        labels=rep(c("Ts", "WT"), 6))
p 
```

Plot with log-transformation, without pseudocounts: Boxplots show statistics for features which are cleaved at all, not for all features irrespective if cleaved or not.

```{r}
df_PSS_features_overlap_perKb$type <- as.factor(df_PSS_features_overlap_perKb$type)
magma_colors <- magma(length(levels(df_PSS_features_overlap_perKb$type))/2, alpha = 0.6, begin = 0, end = 1, direction = 1)[c(1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9)]

p <- ggplot(data=df_PSS_features_overlap_perKb, aes(x=type, y=counts_per_kb, fill=type)) + 
  geom_boxplot(outlier.shape=NA) + geom_jitter(color="black", size=0.05, alpha=0.9, show.legend=FALSE)+ 
  scale_fill_manual(values=magma_colors)+
  theme_light()+ theme(legend.position = "none") +
  labs(fill="", y="Number of PSS per kb", x="") + scale_y_continuous(trans="log10") + scale_x_discrete(breaks=c("3UTR-down", "3UTR-up", "5UTR-down", "5UTR-up", "asRNA-down", "asRNA-up", "CDS-down", "CDS-up", "CRISPR-down", "CRISPR-up", "ncRNA-down","ncRNA-up"), labels=c("Ts\n3'UTR", "WT\n3'UTR", "Ts\n5'UTR", "WT\n5'UTR", "Ts\nasRNA", "WT\nasRNA", "Ts\nCDS", "WT\nCDS", "Ts\nCRISPR", "WT\nCRISPR", "Ts\nncRNA", "WT\nncRNA"))
#        labels=rep(c("Ts", "WT"), 6))
p 

ggsave("output/barplots_overlapFeatures/violin_NumberPSS_perKb.pdf", plot=p, width = 14, height = 7, units="cm")
```

### Further analysis of statistics of number of PSS overlapping certain feature

Statistics for different feature types: 

```{r}
summary(df_PSS_features_overlap_perKb[which(grepl("CRISPR-up", df_PSS_features_overlap_perKb$type, fixed=TRUE)),]$counts_per_kb)
summary(df_PSS_features_overlap_perKb[which(grepl("CRISPR-down", df_PSS_features_overlap_perKb$type, fixed=TRUE)),]$counts_per_kb)
summary(df_PSS_features_overlap_perKb[which(grepl("CDS-up", df_PSS_features_overlap_perKb$type, fixed=TRUE)),]$counts_per_kb)
summary(df_PSS_features_overlap_perKb[which(grepl("CDS-down", df_PSS_features_overlap_perKb$type, fixed=TRUE)),]$counts_per_kb)
summary(df_PSS_features_overlap_perKb[which(grepl("asRNA-up", df_PSS_features_overlap_perKb$type, fixed=TRUE)),]$counts_per_kb)
summary(df_PSS_features_overlap_perKb[which(grepl("asRNA-down", df_PSS_features_overlap_perKb$type, fixed=TRUE)),]$counts_per_kb)
summary(df_PSS_features_overlap_perKb[which(grepl("ncRNA-up", df_PSS_features_overlap_perKb$type, fixed=TRUE)),]$counts_per_kb)
summary(df_PSS_features_overlap_perKb[which(grepl("ncRNA-down", df_PSS_features_overlap_perKb$type, fixed=TRUE)),]$counts_per_kb)
summary(df_PSS_features_overlap_perKb[which(grepl("5UTR-up", df_PSS_features_overlap_perKb$type, fixed=TRUE)),]$counts_per_kb)
summary(df_PSS_features_overlap_perKb[which(grepl("5UTR-down", df_PSS_features_overlap_perKb$type, fixed=TRUE)),]$counts_per_kb)
summary(df_PSS_features_overlap_perKb[which(grepl("3UTR-up", df_PSS_features_overlap_perKb$type, fixed=TRUE)),]$counts_per_kb)
summary(df_PSS_features_overlap_perKb[which(grepl("3UTR-down", df_PSS_features_overlap_perKb$type, fixed=TRUE)),]$counts_per_kb)
summary(df_PSS_features_overlap_perKb[which(grepl("up", df_PSS_features_overlap_perKb$type, fixed=TRUE)),]$counts_per_kb)
summary(df_PSS_features_overlap_perKb[which(grepl("down", df_PSS_features_overlap_perKb$type, fixed=TRUE)),]$counts_per_kb)
```

## Analyse overlap with different RNA features and number of overlaps with those features for comparison rne(WT)/WT

Prepare data frames for the plots and count how many PSS are overlapping with which features, how many features of a certain type are overlapped by PSS, how many PSS are located in each feature per kb.

```{r}
# prepare data.frame for barplot
types <- rep(c("CDS","5UTR", "3UTR", "tRNA", "rRNA", "ncRNA", "asRNA", "CRISPR", "misc"),3)
updown <- c(rep("up",9), rep("down",9), rep("both",9))
df_PSS_features_2 <- data.frame(cbind(type=types, updown=updown))
df_PSS_features_2$number_feat_overlap <- NA 
df_PSS_features_2$number_PSS_overlap <- NA
df_PSS_features_2$number_total <- NA

# extract number of overlaps with different feature types, both for up- and downregulated PSS positions
types <- c("CDS","5UTR", "3UTR", "tRNA", "rRNA", "ncRNA", "asRNA", "CRISPR", "misc")
for(t in types){
  t_feat <- which(features$type == t)
  
  index_up <- which(df_PSS_features_2$type==t & df_PSS_features_2$updown=="up")
  index_down <- which(df_PSS_features_2$type==t & df_PSS_features_2$updown=="down") 
  index_both <- which(df_PSS_features_2$type==t & df_PSS_features_2$updown=="both") 
  
  df_PSS_features_2[index_up,"number_feat_overlap"] <- sum(countOverlaps(features[t_feat], PSS_Ranges_dWTtodWT)>0) # count number of features affected
  df_PSS_features_2[index_up,"number_PSS_overlap"] <- sum(countOverlaps(PSS_Ranges_dWTtodWT, features[t_feat])>0) # count where PSS are located
  df_PSS_features_2[index_down,"number_feat_overlap"] <- sum(countOverlaps(features[t_feat], PSS_Ranges_WTtodWT)>0) # count number of features affected
  df_PSS_features_2[index_down,"number_PSS_overlap"] <- sum(countOverlaps(PSS_Ranges_WTtodWT, features[t_feat])>0) # count where PSS are located
  df_PSS_features_2[index_both,"number_feat_overlap"] <- sum(countOverlaps(features[t_feat], PSS_Ranges_WTtodWT)>0 | countOverlaps(features[t_feat], PSS_Ranges_dWTtodWT)>0) # count number of features affected
  df_PSS_features_2[index_both,"number_PSS_overlap"] <- sum(countOverlaps(PSS_Ranges_WTtodWT, features[t_feat])>0) + sum(countOverlaps(PSS_Ranges_dWTtodWT, features[t_feat])>0) # count where PSS are located
  
  df_PSS_features_2[df_PSS_features_2$type==t,"number_total"] <- length(features[t_feat])
  }
```

```{r}
df_PSS_features_2
write.csv(df_PSS_features_2, file="output/overlap_RNAfeatures_PSS_rneWT-WT-comparison.csv")
```

for TUs:

```{r}
sum(countOverlaps(TUs, PSS_Ranges_dWTtodWT)>0)
sum(countOverlaps(TUs, PSS_Ranges_WTtodWT)>0)
sum((countOverlaps(TUs, PSS_Ranges_dWTtodWT)|countOverlaps(TUs, PSS_Ranges_WTtodWT))>0)
```

### Create bar plots

Do further processing of data frames.

```{r}
df_PSS_features_barplot_2 <- subset(df_PSS_features_2, df_PSS_features_2$updown=="up" | df_PSS_features_2$updown=="down")

total_overlaps_up <- sum(countOverlaps(PSS_Ranges_WT, features)>0)
total_overlaps_down <- sum(countOverlaps(PSS_Ranges_TV, features)>0)

df_PSS_features_barplot_2[,"number_feat_overlap"] <- as.integer(df_PSS_features_barplot_2[,"number_feat_overlap"])/as.integer(df_PSS_features_barplot_2[,"number_total"])*100

# create column  with absolute numbers
df_PSS_features_barplot_2$number_PSS_overlap_absolute <- NA
df_PSS_features_barplot_2[df_PSS_features_barplot_2$updown=="up",]$number_PSS_overlap_absolute <- as.integer(df_PSS_features_barplot_2[df_PSS_features_barplot_2$updown=="up","number_PSS_overlap"])
df_PSS_features_barplot_2[df_PSS_features_barplot_2$updown=="down",]$number_PSS_overlap_absolute <- as.integer(df_PSS_features_barplot_2[df_PSS_features_barplot_2$updown=="down","number_PSS_overlap"])

# calculate percentages
df_PSS_features_barplot_2[df_PSS_features_barplot_2$updown=="up","number_PSS_overlap"] <- as.integer(df_PSS_features_barplot_2[df_PSS_features_barplot_2$updown=="up","number_PSS_overlap"])/total_overlaps_up *100
df_PSS_features_barplot_2[df_PSS_features_barplot_2$updown=="down","number_PSS_overlap"] <- as.integer(df_PSS_features_barplot_2[df_PSS_features_barplot_2$updown=="down","number_PSS_overlap"])/total_overlaps_down *100

# rename types (5'UTR instead of 5UTR, 3'UTR instead of 3UTR)
df_PSS_features_barplot_2[,"type"] <- rep(c("CDS","5'UTR", "3'UTR", "tRNA", "rRNA", "ncRNA", "asRNA", "CRISPR", "misc"),2)

# reduce plot to information I actually care about
df_PSS_features_barplot_2 <- df_PSS_features_barplot_2[which(!df_PSS_features_barplot_2$type=="rRNA"),] # rRNAs cannot be counted here, because multireads were excluded from analysis
df_PSS_features_barplot_2 <- df_PSS_features_barplot_2[which(!df_PSS_features_barplot_2$type=="misc"),] # misc are actually only genes which are split by plasmid / chromosome beginning and two features (NC-2306445, NC-3547510) where I never figured out what they are. One PSS overlaps with sll8049-1. So I think one can savely ignore those
```

Do actual plotting.

```{r}
# cast type, updown as factors to influence order in which they show up in the plots
df_PSS_features_barplot_2$type <- factor(df_PSS_features_barplot_2$type, levels=c("tRNA", "asRNA", "ncRNA", "CRISPR", "3'UTR", "5'UTR", "CDS"))
df_PSS_features_barplot_2$updown <- c(rep("rne(WT)", 7), rep("WT",7))
df_PSS_features_barplot_2$updown <- factor(df_PSS_features_barplot_2$updown, levels=c("rne(WT)", "WT"))

# Plot: How many features of a certain kind are overlapped by PSS?
p <- ggplot(data=df_PSS_features_barplot_2, aes(x=type,y=number_feat_overlap, fill=updown)) + geom_bar(stat="identity", position="dodge") + theme_light()+ xlab("") + ylab("Percentage PSS (%)") + scale_fill_manual(name="", values=c("#005a96ff", "#e69f00ff"), breaks=c("rne(WT)", "WT"), labels=c("rne(WT)", "WT"))
p
ggsave(filename = "output/barplots_overlapFeatures/barplot_percentage_of_allThisFeature_rneWT-WT-comparison.pdf", plot = p, width = 14, height = 7, units = "cm")

# Plots: How many PSS are localized in which kind of feature?
p <- ggplot(data=df_PSS_features_barplot_2, aes(x=updown,y=number_PSS_overlap, fill=type)) + geom_bar(stat="identity", position="fill") + theme_light()+ xlab("") + ylab("Percentage of all PSS (%)") + scale_fill_brewer(palette="Paired", direction=1)#scale_fill_OkabeIto(name="", order=c(2:8,1))
p
ggsave(filename = "output/barplots_overlapFeatures/barplot_percentage_ofAllPSS_rneWT-WT-comparison.pdf", plot = p, width = 7, height = 7, units = "cm")

p <- ggplot(data=df_PSS_features_barplot_2, aes(x=updown,y=number_PSS_overlap_absolute, fill=type)) + geom_bar(stat="identity", position="stack") + theme_light()+ xlab("") + ylab("Number PSS") + scale_fill_brewer(palette="Paired", direction=1)#scale_fill_OkabeIto(name="", order=c(2:8,1))
p
ggsave(filename = "output/barplots_overlapFeatures/barplot_absolute_ofAllPSS_rneWT-WT-comparison.pdf", plot = p, width = 7, height = 7, units = "cm")
```

## GO and KEGG enrichment in set of detected PSS

Control if, in general, PSS are rather detected in certain set of genes. GO annotation only exists for CDS, not for other features: Therefore, only use CDS for functional enrichment. 

Detectable PSS are enriched in genes associated with photosynthesis or ribosomes. I assume both sets are, compared to other sets of genes, highly transcribed and that's the reason why PSS can be detected in those genes. Probably, there are also stable processed RNA fragments created from other sets of transcripts, but they might be too lowly transcribed to be captured by tagRNA-Seq.

```{r}
CDS_features <- features[which(features$type=="CDS")]
```

```{r}
locus_tags_all_PSS <- CDS_features[which(countOverlaps(CDS_features, PSS_advReduce_Ranges)>0)]$locus_tag
# compared to all CDS
kegg_PSS_all_enrich <- kegg_functional_enrichment_locusList(locus_tags_all_PSS, CDS_features$locus_tag, write=TRUE, path="output/enrichment/KEGG_allPSS.csv")
go_PSS_all_enrich <- go_functional_enrichment_locusList(locus_tags_all_PSS, CDS_features$locus_tag, write=TRUE, path="output/enrichment/GO_allPSS.csv")
```

```{r}
p <- dotplot(kegg_PSS_all_enrich)
p
ggsave("output/enrichment/KEGG_dotplot_allPSS.pdf", plot=p, width=20, height=14, units="cm")
p <- dotplot(go_PSS_all_enrich, showCategory=26)
p
ggsave("output/enrichment/GO_dotplot_allPSS.pdf", plot=p, width=20, height=14, units="cm")
```

Compared to the positions where PSS were generally detected, no terms are enriched in set of PSS upregulated (higher in *rne*(WT)).

```{r}
# enrichment in rne(WT) PSS
locus_tags_up <- CDS_features[which(countOverlaps(CDS_features, PSS_Ranges_WT)>0)]$locus_tag
# compared to all CDS
kegg_PSS_up_enrich <- kegg_functional_enrichment_locusList(locus_tags_up, CDS_features$locus_tag, write=TRUE, path="output/enrichment/KEGG_PSS_rneWT_universeAllCDS.csv")
go_PSS_up_enrich <- go_functional_enrichment_locusList(locus_tags_up, CDS_features$locus_tag, write=TRUE, path="output/enrichment/GO_PSS_rneWT_universeAllCDS.csv")
# compared to universe: Where are PSS generally localized / what was detectable
kegg_PSS_up_enrich_2 <- kegg_functional_enrichment_locusList(list_of_genes=locus_tags_up, universe_tags=locus_tags_all_PSS, write=TRUE, path="output/enrichment/KEGG_PSS_rneWT_universeDetectedCDS.csv")
go_PSS_up_enrich_2 <- go_functional_enrichment_locusList(locus_tags_up, universe_tags=locus_tags_all_PSS, write=TRUE, path="output/enrichment/GO_PSS_rneWT_universeDetectedCDS.csv")
```

When using all positions of PSS as universe, GO term phycobilisome is enriched in the PSS ranges *rne*(WT) data set.

```{r}
# enrichment in rne(TV) PSS
locus_tags_down <- CDS_features[which(countOverlaps(CDS_features, PSS_Ranges_TV)>0)]$locus_tag
# compared to all CDS
kegg_PSS_down_enrich <- kegg_functional_enrichment_locusList(locus_tags_down, CDS_features$locus_tag, write=TRUE, path="output/enrichment/KEGG_PSS_TV_universeAllCDS.csv")
go_PSS_down_enrich <- go_functional_enrichment_locusList(locus_tags_down, CDS_features$locus_tag, write=TRUE, path="output/enrichment/GO_PSS_TV_universeAllCDS.csv")
# compared to universe: Where are PSS generally localized / what was detectable
kegg_PSS_down_enrich_2 <- kegg_functional_enrichment_locusList(locus_tags_down, locus_tags_all_PSS, write=TRUE, path="output/enrichment/KEGG_PSS_TV_universeDetectedCDS.csv")
go_PSS_down_enrich_2 <- go_functional_enrichment_locusList(locus_tags_down, locus_tags_all_PSS, write=TRUE, path="output/enrichment/GO_PSS_TV_universeDetectedCDS.csv")
```

```{r}
p <- dotplot(go_PSS_down_enrich_2)
p
ggsave("output/enrichment/GO_dotplot_PSS_rneTV.pdf", plot=p, width=20, height=14, units="cm")
```

## Distance of PSS to Start / Stop position

```{r}
count_overlaps_xNt_upDownstream <- function(Ranges_object, Ranges_object_2, sequence_object, start_stop="start", len=25){
  # function returns df with total number overlapping between Ranges_object and Ranges_object_2, iterating from start or stop codon (choose by setting start_stop to "start" or "stop") of Ranges_object +/- nucleotide positions. 
  
  # prepare df to return
  df_overlaps <- data.frame(rbind(rep("NA", length((-len):(+len)))))
  names(df_overlaps) <- (-len):(+len)
    
  # extract lengths of sequences (needed for catching cases in which start_end -len or +len exceeds chromosome/plasmid length) -> if this is the case: since circular DNA: start from other end with counting again (see below)
  lengths <- c()
  for(i in 1:length(sequence_object)){
    lengths[i] <- width(sequence_object[i])
  }
  names(lengths) <- names(sequence_object)
  
  # extract info about what to extract (depending on strength: upstream corresponds to either + or -)
  strands <- data.frame(Ranges_object)[,5]
  plus_strand <- which(strand(Ranges_object)=="+")
  minus_strand <- which(strand(Ranges_object)=="-")
  seqs <- as.character(data.frame(Ranges_object)[,1])
  
  for(d in (-len):(+len)){
    positions <- c()
  
    # get positions of start_end on plus and minus strand
    if(start_stop=="start"){
      positions[plus_strand] <- start(Ranges_object[plus_strand])-(-d) # e.g. - (- -25) -> corresponds to -25
      positions[minus_strand] <- end(Ranges_object[minus_strand])+(-d) # e.g. + (- -25) -> corresponds to +25
    }else{
      positions[plus_strand] <- end(Ranges_object[plus_strand])-(-d) # e.g. - (- -25) -> corresponds to -25
      positions[minus_strand] <- start(Ranges_object[minus_strand])+(-d) # e.g. + (- -25) -> corresponds to +25
    }
    # positions < 0
    indices <- which(positions < 0)
    positions[indices] <- lengths[seqs[indices]]-(-positions[indices])
    
    # positions at which positions > length of respective plasmid / chromosome
    indices <- which(positions>lengths[seqs])
    positions[indices] <- positions[indices]-lengths[seqs[indices]]
    
    # create GRanges object
    temp_GRanges <- GRanges(seqnames=seqs, ranges=IRanges(start = positions, end=positions), strand = strands)
    
    # count overlaps    
    overlap_vect <- countOverlaps(temp_GRanges, Ranges_object_2)
    df_overlaps[,as.character(d)] <- sum(overlap_vect)
  }
  
  return(df_overlaps)
}
```

### For PSS which are upregulated in rne(WT)

```{r}
overlaps_PSS_up_start_CDS <- count_overlaps_xNt_upDownstream(features[which(features$type=="CDS")], PSS_Ranges_WT, syne_fasta, len = 300, start_stop = "start")
overlaps_PSS_up_stop_CDS <- count_overlaps_xNt_upDownstream(features[which(features$type=="CDS")], PSS_Ranges_WT, syne_fasta, len = 300, start_stop = "stop")

overlaps_PSS_up_start_CDS_ggplot <- data.frame(t(overlaps_PSS_up_start_CDS))
overlaps_PSS_up_start_CDS_ggplot$nt_pos <- as.numeric(row.names(overlaps_PSS_up_start_CDS_ggplot))
names(overlaps_PSS_up_start_CDS_ggplot)[1] <- "count"

overlaps_PSS_up_stop_CDS_ggplot <- data.frame(t(overlaps_PSS_up_stop_CDS))
overlaps_PSS_up_stop_CDS_ggplot$nt_pos <- as.numeric(row.names(overlaps_PSS_up_stop_CDS_ggplot))
names(overlaps_PSS_up_stop_CDS_ggplot)[1] <- "count"
```

```{r}
p <- ggplot(overlaps_PSS_up_start_CDS_ggplot, aes(x=nt_pos, y=count)) + geom_line(size=0.5, color="#005a96ff") + theme_light() + labs(x="Distance relative to start codon (nt)", y="Number of cleavage sites")+ geom_vline(aes(xintercept=0), linetype=2, color="darkgray")# + ylim(0,8)
p
ggsave("output/distance_startStop/PSS_rneWT_count_relativeStartCodon.pdf", plot=p, width=10, height=7, units="cm")
```


```{r}
p <- ggplot(overlaps_PSS_up_stop_CDS_ggplot, aes(x=nt_pos, y=count)) + geom_line(size=0.5, color="#005a96ff") + theme_light() + labs(x="Distance relative to stop codon (nt)", y="Number of cleavage sites") + geom_vline(aes(xintercept=0), linetype=2, color="darkgray")# + ylim(0,8)
p
ggsave("output/distance_startStop/PSS_rneWT_count_relativeStopCodon.pdf", plot=p, width=10, height=7, units="cm")
```

### For PSS which are upregulated in *rne*(5p)

```{r}
overlaps_PSS_down_start_CDS <- count_overlaps_xNt_upDownstream(features[which(features$type=="CDS")], PSS_Ranges_TV, syne_fasta, len = 300, start_stop = "start")
overlaps_PSS_down_stop_CDS <- count_overlaps_xNt_upDownstream(features[which(features$type=="CDS")], PSS_Ranges_TV, syne_fasta, len = 300, start_stop = "stop")

overlaps_PSS_down_start_CDS_ggplot <- data.frame(t(overlaps_PSS_down_start_CDS))
overlaps_PSS_down_start_CDS_ggplot$nt_pos <- as.numeric(row.names(overlaps_PSS_down_start_CDS_ggplot))
names(overlaps_PSS_down_start_CDS_ggplot)[1] <- "count"

overlaps_PSS_down_stop_CDS_ggplot <- data.frame(t(overlaps_PSS_down_stop_CDS))
overlaps_PSS_down_stop_CDS_ggplot$nt_pos <- as.numeric(row.names(overlaps_PSS_down_stop_CDS_ggplot))
names(overlaps_PSS_down_stop_CDS_ggplot)[1] <- "count"
```

```{r}
p <- ggplot(overlaps_PSS_down_start_CDS_ggplot, aes(x=nt_pos, y=count)) + geom_line(size=0.5, color="#e69f00ff") + theme_light() + labs(x="Distance relative to start codon (nt)", y="Number of cleavage sites")+ geom_vline(aes(xintercept=0), linetype=2, color="darkgray")# + ylim(0,8)
p
ggsave("output/distance_startStop/PSS_TV_count_relativeStartCodon.pdf", plot=p, width=10, height=7, units="cm")
```

```{r}
p <- ggplot(overlaps_PSS_down_stop_CDS_ggplot, aes(x=nt_pos, y=count)) + geom_line(size=0.5, color="#e69f00ff") + theme_light() + labs(x="Distance relative to stop codon (nt)", y="Number of cleavage sites")+ geom_vline(aes(xintercept=0), linetype=2, color="darkgray")# + ylim(0,8)
p
ggsave("output/distance_startStop/PSS_TV_count_relativeStopCodon.pdf", plot=p, width=10, height=7, units="cm")
```

## Perform RNA Fold with sliding window approach

To investigate secondary structures around processing sites: Extract 150nt upstream / downstream of processing sites and calculate minimum free energy ($\Delta$G). Do this also for random peaks, start and end positions of TUs, start and end positions of CDS. Use sliding window approach to reduce problem of transcript boundaries.

### Processing Sites

```{r}
# export sequences from peaks + / - 150nt
peaks_WT_150 <- extract_RNA_sequences(PSS_Ranges_WT, syne_fasta, 150)
peaks_TV_150 <- extract_RNA_sequences(PSS_Ranges_TV, syne_fasta, 150)

writeXStringSet(peaks_WT_150, "output/RNAfold/peaks_WT_150.fasta", append=FALSE,
                compress=FALSE, compression_level=NA, format="fasta")
writeXStringSet(peaks_TV_150, "output/RNAfold/peaks_TV_150.fasta", append=FALSE,
                compress=FALSE, compression_level=NA, format="fasta")
```

run from command line (!takes a long time!): 
python RNAfold/RNAfold_inputFasta_outputMfeTable.py RNAfold/peaks_WT_150.fasta RNAfold/mfe_files/mfe_peaks_WT_150.tsv 50
python RNAfold/RNAfold_inputFasta_outputMfeTable.py RNAfold/peaks_TV_150.fasta RNAfold/mfe_files/mfe_peaks_TV_150.tsv 50

```{r}
mfe_PSS_up <- read.delim("output/RNAfold/mfe_files/mfe_peaks_WT_150.tsv", header=TRUE, row.names=1)
mfe_PSS_up_control <- read.delim("output/RNAfold/mfe_files/mfe_peaks_WT_150_control.tsv", header=TRUE, row.names=1)
mfe_PSS_down <- read.delim("output/RNAfold/mfe_files/mfe_peaks_TV_150.tsv", header=TRUE, row.names=1)
mfe_PSS_down_control <- read.delim("output/RNAfold/mfe_files/mfe_peaks_TV_150_control.tsv", header=TRUE, row.names=1)
```

Original sequences represented nucleotide positions before (-150:-1) and after (+1:+150) cleavage position. With the floating window approach etc., this translates to position "150.5" (index 126).

```{r}
df_mfe_PSS_quartiles <- data.frame(cbind(ntpos=c(rep(c(-125:125),2)), mfe_distrib=c(apply(mfe_PSS_up, 1, median), apply(mfe_PSS_down, 1, median),apply(mfe_PSS_up, 1, quantile,probs=0.25), apply(mfe_PSS_down, 1, quantile,probs=0.25),apply(mfe_PSS_up, 1,  quantile,probs=0.75), apply(mfe_PSS_down, 1,  quantile,probs=0.75))))
df_mfe_PSS_quartiles$updown <- rep(c(rep("up",251), rep("down", 251)),3)
df_mfe_PSS_quartiles$median_quartile <- c(rep("median", 502), rep("1quartile", 502), rep("3quartile",502))

mean_or_median = mean
df_mfe_PSS <- data.frame(cbind(ntpos=c(rep(c(-125:125),4)), mfe=c(apply(mfe_PSS_up, 1, mean_or_median), apply(mfe_PSS_down, 1, mean_or_median), apply(mfe_PSS_up_control, 1, mean_or_median), apply(mfe_PSS_down_control,1, mean_or_median))))
df_mfe_PSS$updown <- rep(c(rep("up",251), rep("down", 251)),2)
df_mfe_PSS$control <- c(rep("data", 502), rep("control", 502))
```

Plot with shuffled data and non-shuffled data

```{r}
p <- ggplot(data=df_mfe_PSS, aes(x=ntpos, y=mfe, color=updown)) + geom_vline(aes(xintercept=0), linetype=2, color="darkgray") + geom_line(aes(linetype=control), size=0.5) + theme_light() + scale_linetype_manual(values=c(4,1), name="Control", breaks=c("control", "data"), labels=c("shuffled", "data")) + scale_color_manual(values=c("#005a96ff", "#e69f00ff"), name  ="Peaks", breaks=c("up", "down"), labels=c("rne(WT)5ps", "rne(5p)>WT")) + xlab("Distance Relative to Cleavage Site (nt)") + ylab(expression(Delta*"G")) + theme(legend.justification=c(1,1), legend.position=c(0.95,0.95), legend.background = element_rect(colour="gray", linetype="solid", fill="white", size=.5)) + ylim(-10,-4.75)
p
ggsave("output/RNAfold/figures/deltaG_PSS_shuffled.pdf", plot=p, width=10, height=7, units="cm")
```

Plot with quartiles (1st, median, 3rd)

```{r}
p <- ggplot(data=df_mfe_PSS_quartiles, aes(x=ntpos, y=mfe_distrib, color=updown, linetype=median_quartile)) + geom_vline(aes(xintercept=0), linetype=2, color="darkgray") + geom_line(size=0.5) + theme_light() + 
  scale_color_manual(values=c("#005a96ff", "#e69f00ff"), name  ="Peaks", breaks=c("up", "down"), labels=c("rne(WT)>5p", "rne(5p)>WT")) + 
  scale_linetype_manual(name="Quartiles",values=c(3,1,3), breaks=c("1quartile", "median", "3quartile"), labels=c("1st", "2nd", "3rd")) +
  xlab("Distance Relative to Cleavage Site (nt)") + xlab("Distance Relative to Cleavage Site (nt)") + ylab(expression(Delta*"G")) + theme(legend.justification=c(1,1), legend.position=c(0.95,0.95), legend.background = element_rect(colour="gray", linetype="solid", fill="white", size=.5)) + ylim(-14,-2)
p

ggsave("output/RNAfold/figures/deltaG_PSS_quartiles.pdf", plot=p, width=10, height=7, units="cm")
```

```{r}
p <- ggplot(data=subset(df_mfe_PSS, df_mfe_PSS$control=="data"), aes(x=ntpos, y=mfe, color=updown)) + geom_vline(aes(xintercept=0), linetype=2, color="darkgray") + geom_line(size=0.5) + theme_light() + scale_linetype_manual(values=c(4,1), name="Control", breaks=c("control", "data"), labels=c("shuffled", "data")) + scale_color_manual(values=c("#005a96ff", "#e69f00ff"), name  ="Peaks", breaks=c("up", "down"), labels=c("rne(WT)>5p", "rne(5p)>WT")) + xlab("Distance Relative to Cleavage Site (nt)") + ylab(expression(Delta*"G")) + theme(legend.justification=c(1,1), legend.position=c(0.95,0.95), legend.background = element_rect(colour="gray", linetype="solid", fill="white", size=.5)) + ylim(-10,-4.75)
p

ggsave("output/RNAfold/figures/deltaG_PSS.pdf", plot=p, width=10, height=7, units="cm")
```

run from command line (!takes a long time!): 
python RNAfold/RNAfold_inputFasta_outputMfeTable.py RNAfold/peaks_WT_150.fasta RNAfold/mfe_files/mfe_peaks_WT_150_25nt.tsv 25
python RNAfold/RNAfold_inputFasta_outputMfeTable.py RNAfold/peaks_TV_150.fasta RNAfold/mfe_files/mfe_peaks_TV_150_25nt.tsv 25

```{r}
mfe_PSS_25nt_up <- read.delim("output/RNAfold/mfe_files/mfe_peaks_WT_150_25nt.tsv", header=TRUE, row.names=1)
mfe_PSS_25nt_down <- read.delim("output/RNAfold/mfe_files/mfe_peaks_TV_150_25nt.tsv", header=TRUE, row.names=1)
mfe_PSS_25nt_up_control <- read.delim("output/RNAfold/mfe_files/mfe_peaks_WT_150_25nt_control.tsv", header=TRUE, row.names=1)
mfe_PSS_25nt_down_control <- read.delim("output/RNAfold/mfe_files/mfe_peaks_TV_150_25nt_control.tsv", header=TRUE, row.names=1)
```

Processing site at position 150.5. When x-axis is labeled from -137.5:137.5, this corresponds to -0

```{r}
df_mfe_PSS_25nt_quartiles <- data.frame(cbind(ntpos=c(rep(c(-137.5:137.5),2)), mfe_distrib=c(apply(mfe_PSS_25nt_up, 1, median), apply(mfe_PSS_25nt_down, 1, median),apply(mfe_PSS_25nt_up, 1, quantile,probs=0.25), apply(mfe_PSS_25nt_down, 1, quantile,probs=0.25),apply(mfe_PSS_25nt_up, 1,  quantile,probs=0.75), apply(mfe_PSS_25nt_down, 1,  quantile,probs=0.75))))
df_mfe_PSS_25nt_quartiles$updown <- rep(c(rep("up",276), rep("down", 276)),3)
df_mfe_PSS_25nt_quartiles$median_quartile <- c(rep("median", 552), rep("1quartile", 552), rep("3quartile",552))

mean_or_median = mean
df_mfe_PSS_25nt <- data.frame(cbind(ntpos=c(rep(c(-137.5:137.5),4)), mfe=c(apply(mfe_PSS_25nt_up, 1, mean_or_median), apply(mfe_PSS_25nt_down, 1, mean_or_median), apply(mfe_PSS_25nt_up_control, 1, mean_or_median), apply(mfe_PSS_25nt_down_control,1, mean_or_median))))
df_mfe_PSS_25nt$updown <- rep(c(rep("up",276), rep("down", 276)),2)
df_mfe_PSS_25nt$control <- c(rep("data", 552), rep("control", 552))
```

```{r}
p <- ggplot(data=df_mfe_PSS_25nt, aes(x=ntpos, y=mfe, color=updown)) + geom_vline(aes(xintercept=0), linetype=2, color="darkgray") + geom_line(aes(linetype=control), size=0.5) + theme_light() + scale_linetype_manual(values=c(4,1), name="Control", breaks=c("control", "data"), labels=c("shuffled", "data")) + scale_color_manual(values=c("#005a96ff", "#e69f00ff"), name  ="Peaks", breaks=c("up", "down"), labels=c("rne(WT)", "rne(5p)")) + xlab("Distance Relative to Cleavage Site (nt)") + ylab(expression(Delta*"G")) + theme(legend.justification=c(1,1), legend.position=c(0.95,0.95), legend.background = element_rect(colour="gray", linetype="solid", fill="white", size=.5)) +ylim(-3.4,-1)
p
ggsave("output/RNAfold/figures/deltaG_PSS_25nt_shuffled.pdf", plot=p, width=10, height=7, units="cm")

p <- ggplot(data=df_mfe_PSS_25nt_quartiles, aes(x=ntpos, y=mfe_distrib, color=updown, linetype=median_quartile)) + geom_vline(aes(xintercept=0), linetype=2, color="darkgray") + geom_line(size=0.5) + theme_light() + 
  scale_color_manual(values=c("#005a96ff", "#e69f00ff"), name  ="Peaks", breaks=c("up", "down"), labels=c("rne(WT)", "rne(5p)")) + 
  scale_linetype_manual(name="Quartiles",values=c(3,1,3), breaks=c("1quartile", "median", "3quartile"), labels=c("1st", "2nd", "3rd")) +
  xlab("Distance Relative to Cleavage Site (nt)") + xlab("Distance Relative to Cleavage Site (nt)") + ylab(expression(Delta*"G")) + theme(legend.justification=c(1,1), legend.position=c(0.95,0.95), legend.background = element_rect(colour="gray", linetype="solid", fill="white", size=.5)) + ylim(-5.1,0.1)
p
ggsave("output/RNAfold/figures/deltaG_PSS_25nt_quartiles.pdf", plot=p, width=10, height=7, units="cm")

p <- ggplot(data=subset(df_mfe_PSS_25nt, df_mfe_PSS_25nt$control=="data"), aes(x=ntpos, y=mfe, color=updown)) + geom_vline(aes(xintercept=0), linetype=2, color="darkgray") + geom_line(size=0.5) + theme_light() + scale_linetype_manual(values=c(4,1), name="Control", breaks=c("control", "data"), labels=c("shuffled", "data")) + scale_color_manual(values=c("#005a96ff", "#e69f00ff"), name  ="Peaks", breaks=c("up", "down"), labels=c("rne(WT)", "rne(5p)")) + xlab("Distance Relative to Cleavage Site (nt)") + ylab(expression(Delta*"G")) + theme(legend.justification=c(1,1), legend.position=c(0.95,0.95), legend.background = element_rect(colour="gray", linetype="solid", fill="white", size=.5)) +ylim(-3.4,-1)
p
ggsave("output/RNAfold/figures/deltaG_PSS_25nt.pdf", plot=p, width=10, height=7, units="cm")
```

### Random Sites

```{r}
# use same amount of random positions
shuffle_Ranges_perPlasmid <- function(Ranges_object, sequence_object, seed=NULL){
  set.seed(seed)

  # extract lengths of sequences
  lengths <- c()
  for(i in 1:length(sequence_object)){
    lengths[i] <- width(sequence_object[i])
  }
  names(lengths) <- names(sequence_object)

  # initialise new_ranges, end has to be set according to length of plasmids / chromosome
  new_ranges <- Ranges_object
  start(new_ranges) <- rep(1, length(new_ranges))
  
  # do actual shuffling  
  for(seq_i in 1:length(lengths)){
    seq <- names(lengths)[seq_i]
    indices <- which(seqnames(new_ranges)==seq)
    # set ends to max possible length to avoid width < 0
    end(new_ranges[indices]) <- rep(lengths[seq], length(new_ranges[indices]))
    
    # create random numbers
    start(new_ranges[indices]) <- round(runif(length(new_ranges[indices]), 1, lengths[seq]))
    end(new_ranges[indices]) <- start(new_ranges[indices])
  }
  
  return(new_ranges)
}

random_up_Ranges <- shuffle_Ranges_perPlasmid(PSS_Ranges_WT, syne_fasta, 42)
random_down_Ranges <- shuffle_Ranges_perPlasmid(PSS_Ranges_TV, syne_fasta, 42)

random_up_150 <- extract_RNA_sequences(random_up_Ranges, syne_fasta, 150)
random_down_150 <- extract_RNA_sequences(random_down_Ranges, syne_fasta, 150)

writeXStringSet(random_up_150, "output/RNAfold/random_up_150.fasta", append=FALSE,
                compress=FALSE, compression_level=NA, format="fasta")
writeXStringSet(random_down_150, "output/RNAfold/random_down_150.fasta", append=FALSE,
                compress=FALSE, compression_level=NA, format="fasta")
```

run from command line (!takes a long time!): 
python RNAfold/RNAfold_inputFasta_outputMfeTable.py RNAfold/random_up_150.fasta RNAfold/mfe_files/mfe_random_up_150.tsv 50
python RNAfold/RNAfold_inputFasta_outputMfeTable.py RNAfold/random_down_150.fasta RNAfold/mfe_files/mfe_random_down_150.tsv 50

```{r}
mfe_random_up <- read.delim("output/RNAfold/mfe_files/mfe_random_up_150.tsv", header=TRUE, row.names=1)
mfe_random_up_control <- read.delim("output/RNAfold/mfe_files/mfe_random_up_150_control.tsv", header=TRUE, row.names=1)
mfe_random_down <- read.delim("output/RNAfold/mfe_files/mfe_random_down_150.tsv", header=TRUE, row.names=1)
mfe_random_down_control <- read.delim("output/RNAfold/mfe_files/mfe_random_down_150_control.tsv", header=TRUE, row.names=1)
```

```{r}
df_mfe_random_quartiles <- data.frame(cbind(ntpos=c(rep(c(-125:125),2)), mfe_distrib=c(apply(mfe_random_up, 1, median), apply(mfe_random_down, 1, median),apply(mfe_random_up, 1, quantile,probs=0.25), apply(mfe_random_down, 1, quantile,probs=0.25),apply(mfe_random_up, 1,  quantile,probs=0.75), apply(mfe_random_down, 1,  quantile,probs=0.75))))
df_mfe_random_quartiles$updown <- rep(c(rep("up",251), rep("down", 251)),3)
df_mfe_random_quartiles$median_quartile <- c(rep("median", 502), rep("1quartile", 502), rep("3quartile",502))

mean_or_median = mean
df_mfe_random <- data.frame(cbind(ntpos=c(rep(c(-125:125),4)), mfe=c(apply(mfe_random_up, 1, mean_or_median), apply(mfe_random_down, 1, mean_or_median), apply(mfe_random_up_control, 1, mean_or_median), apply(mfe_random_down_control,1, mean_or_median))))
df_mfe_random$updown <- rep(c(rep("up",251), rep("down", 251)),2)
df_mfe_random$control <- c(rep("data", 502), rep("control", 502))
```

Plot with shuffled data and non-shuffled data

```{r}
p <- ggplot(data=df_mfe_random, aes(x=ntpos, y=mfe, color=updown)) + geom_vline(aes(xintercept=0), linetype=2, color="darkgray") + geom_line(aes(linetype=control), size=0.5) + theme_light() + scale_linetype_manual(values=c(4,1), name="Control", breaks=c("control", "data"), labels=c("shuffled", "data")) + scale_color_manual(values=c("#005a96ff", "#e69f00ff"), name  ="Peaks", breaks=c("up", "down"), labels=c("rne(WT)>Ts", "rne(5p)>WT")) + xlab("Distance Relative to Cleavage Site (nt)") + ylab(expression(Delta*"G")) + theme(legend.justification=c(1,1), legend.position=c(0.95,0.95), legend.background = element_rect(colour="gray", linetype="solid", fill="white", size=.5)) + ylim(-10,-4.75)
p
ggsave("output/RNAfold/figures/deltaG_random_shuffled.pdf", plot=p, width=10, height=7, units="cm")
```

Plot with quartiles (1st, median, 3rd)

```{r}
p <- ggplot(data=df_mfe_random_quartiles, aes(x=ntpos, y=mfe_distrib, color=updown, linetype=median_quartile)) + geom_vline(aes(xintercept=0), linetype=2, color="darkgray") + geom_line(size=0.5) + theme_light() + 
  scale_color_manual(values=c("#005a96ff", "#e69f00ff"), name  ="Peaks", breaks=c("up", "down"), labels=c("rne(WT)>Ts", "rne(5p)>WT")) + 
  scale_linetype_manual(name="Quartiles",values=c(3,1,3), breaks=c("1quartile", "median", "3quartile"), labels=c("1st", "2nd", "3rd")) +
  xlab("Distance Relative to Cleavage Site (nt)") + xlab("Distance Relative to Cleavage Site (nt)") + ylab(expression(Delta*"G")) + theme(legend.justification=c(1,1), legend.position=c(0.95,0.95), legend.background = element_rect(colour="gray", linetype="solid", fill="white", size=.5)) + ylim(-14,-2)
p

ggsave("output/RNAfold/figures/deltaG_random_quartiles.pdf", plot=p, width=10, height=7, units="cm")
```

```{r}
p <- ggplot(data=subset(df_mfe_random, df_mfe_PSS$control=="data"), aes(x=ntpos, y=mfe, color=updown)) + geom_vline(aes(xintercept=0), linetype=2, color="darkgray") + geom_line(size=0.5) + theme_light() + scale_linetype_manual(values=c(4,1), name="Control", breaks=c("control", "data"), labels=c("shuffled", "data")) + scale_color_manual(values=c("#005a96ff", "#e69f00ff"), name  ="Peaks", breaks=c("up", "down"), labels=c("rne(WT)>Ts", "rne(5p)>WT")) + xlab("Distance Relative to Cleavage Site (nt)") + ylab(expression(Delta*"G")) + theme(legend.justification=c(1,1), legend.position=c(0.95,0.95), legend.background = element_rect(colour="gray", linetype="solid", fill="white", size=.5)) + ylim(-10,-4.75)
p

ggsave("output/RNAfold/figures/deltaG_random.pdf", plot=p, width=10, height=7, units="cm")
```

run from command line (!takes a long time!): 
python RNAfold/RNAfold_inputFasta_outputMfeTable.py RNAfold/random_up_150.fasta RNAfold/mfe_files/mfe_random_up_150_25nt.tsv 25
python RNAfold/RNAfold_inputFasta_outputMfeTable.py RNAfold/random_down_150.fasta RNAfold/mfe_files/mfe_random_down_150_25nt.tsv 25

```{r}
mfe_random_25nt_up <- read.delim("output/RNAfold/mfe_files/mfe_random_up_150_25nt.tsv", header=TRUE, row.names=1)
mfe_random_25nt_down <- read.delim("output/RNAfold/mfe_files/mfe_random_down_150_25nt.tsv", header=TRUE, row.names=1)
mfe_random_25nt_up_control <- read.delim("output/RNAfold/mfe_files/mfe_random_up_150_25nt_control.tsv", header=TRUE, row.names=1)
mfe_random_25nt_down_control <- read.delim("output/RNAfold/mfe_files/mfe_random_down_150_25nt_control.tsv", header=TRUE, row.names=1)
```

Processing site at position 150.5. When x-axis is labeled from -137.5:137.5, this corresponds to -0

```{r}
df_mfe_random_25nt_quartiles <- data.frame(cbind(ntpos=c(rep(c(-137.5:137.5),2)), mfe_distrib=c(apply(mfe_random_25nt_up, 1, median), apply(mfe_random_25nt_down, 1, median),apply(mfe_random_25nt_up, 1, quantile,probs=0.25), apply(mfe_random_25nt_down, 1, quantile,probs=0.25),apply(mfe_random_25nt_up, 1,  quantile,probs=0.75), apply(mfe_random_25nt_down, 1,  quantile,probs=0.75))))
df_mfe_random_25nt_quartiles$updown <- rep(c(rep("up",276), rep("down", 276)),3)
df_mfe_random_25nt_quartiles$median_quartile <- c(rep("median", 552), rep("1quartile", 552), rep("3quartile",552))

mean_or_median = mean
df_mfe_random_25nt <- data.frame(cbind(ntpos=c(rep(c(-137.5:137.5),4)), mfe=c(apply(mfe_random_25nt_up, 1, mean_or_median), apply(mfe_random_25nt_down, 1, mean_or_median), apply(mfe_random_25nt_up_control, 1, mean_or_median), apply(mfe_random_25nt_down_control,1, mean_or_median))))
df_mfe_random_25nt$updown <- rep(c(rep("up",276), rep("down", 276)),2)
df_mfe_random_25nt$control <- c(rep("data", 552), rep("control", 552))
```

```{r}
p <- ggplot(data=df_mfe_random_25nt, aes(x=ntpos, y=mfe, color=updown)) + geom_vline(aes(xintercept=0), linetype=2, color="darkgray") + geom_line(aes(linetype=control), size=0.5) + theme_light() + scale_linetype_manual(values=c(4,1), name="Control", breaks=c("control", "data"), labels=c("shuffled", "data")) + scale_color_manual(values=c("#005a96ff", "#e69f00ff"), name  ="Peaks", breaks=c("up", "down"), labels=c("rne(WT)>Ts", "rne(5p)>WT")) + xlab("Distance Relative to Cleavage Site (nt)") + ylab(expression(Delta*"G")) + theme(legend.justification=c(1,1), legend.position=c(0.95,0.95), legend.background = element_rect(colour="gray", linetype="solid", fill="white", size=.5)) +ylim(-3.4,-1)
p
ggsave("output/RNAfold/figures/deltaG_random_25nt_shuffled.pdf", plot=p, width=10, height=7, units="cm")

p <- ggplot(data=df_mfe_random_25nt_quartiles, aes(x=ntpos, y=mfe_distrib, color=updown, linetype=median_quartile)) + geom_vline(aes(xintercept=0), linetype=2, color="darkgray") + geom_line(size=0.5) + theme_light() + 
  scale_color_manual(values=c("#005a96ff", "#e69f00ff"), name  ="Peaks", breaks=c("up", "down"), labels=c("rne(WT)>Ts", "rne(5p)>WT")) + 
  scale_linetype_manual(name="Quartiles",values=c(3,1,3), breaks=c("1quartile", "median", "3quartile"), labels=c("1st", "2nd", "3rd")) +
  xlab("Distance Relative to Cleavage Site (nt)") + xlab("Distance Relative to Cleavage Site (nt)") + ylab(expression(Delta*"G")) + theme(legend.justification=c(1,1), legend.position=c(0.95,0.95), legend.background = element_rect(colour="gray", linetype="solid", fill="white", size=.5)) + ylim(-5.1,0.1)
p
ggsave("output/RNAfold/figures/deltaG_random_25nt_quartiles.pdf", plot=p, width=10, height=7, units="cm")

p <- ggplot(data=subset(df_mfe_random_25nt, df_mfe_random_25nt$control=="data"), aes(x=ntpos, y=mfe, color=updown)) + geom_vline(aes(xintercept=0), linetype=2, color="darkgray") + geom_line(size=0.5) + theme_light() + scale_linetype_manual(values=c(4,1), name="Control", breaks=c("control", "data"), labels=c("shuffled", "data")) + scale_color_manual(values=c("#005a96ff", "#e69f00ff"), name  ="Peaks", breaks=c("up", "down"), labels=c("rne(WT)>Ts", "rne(5p)>WT")) + xlab("Distance Relative to Cleavage Site (nt)") + ylab(expression(Delta*"G")) + theme(legend.justification=c(1,1), legend.position=c(0.95,0.95), legend.background = element_rect(colour="gray", linetype="solid", fill="white", size=.5)) +ylim(-3.4,-1)
p
ggsave("output/RNAfold/figures/deltaG_random_25nt.pdf", plot=p, width=10, height=7, units="cm")
```

## For AU content, ACGU content

Check for nucleotide content around processing sites, compare between different sets of processing sites.

```{r}
length_up_down <- 50
peaks_all <- extract_RNA_sequences(PSS_Ranges, syne_fasta, length_up_down)
peaks_up <- extract_RNA_sequences(PSS_Ranges_WT, syne_fasta, length_up_down)
peaks_down <- extract_RNA_sequences(PSS_Ranges_TV, syne_fasta, length_up_down)

cons_mat <- consensusMatrix(peaks_up)
perc_AU_up <- (cons_mat[1,]+cons_mat[4,])/apply(cons_mat[1:4,], 2,sum)
df_perc_ACGU_up <- data.frame(cons_mat[1:4,])/sum(cons_mat[,1])*100
df_perc_ACGU_up <- data.frame(cbind(ntpos=c(-length_up_down:-1,1:length_up_down), t(df_perc_ACGU_up)))
df_perc_AU_up <- df_perc_ACGU_up[,c(1,2,5)]
df_perc_CG_up <- df_perc_ACGU_up[,c(1,3,4)]
df_perc_ACGU_up <- pivot_longer(df_perc_ACGU_up, 2:5)
df_perc_AU_up <- pivot_longer(df_perc_AU_up, 2:3)
df_perc_CG_up <- pivot_longer(df_perc_CG_up, 2:3)

cons_mat <- consensusMatrix(peaks_down)
perc_AU_down <- (cons_mat[1,]+cons_mat[4,])/apply(cons_mat[1:4,], 2,sum)
df_perc_ACGU_down <- data.frame(cons_mat[1:4,])/sum(cons_mat[,1])*100
df_perc_ACGU_down <- data.frame(cbind(ntpos=c(-length_up_down:-1,1:length_up_down), t(df_perc_ACGU_down)))
df_perc_AU_down <- df_perc_ACGU_down[,c(1,2,5)]
df_perc_CG_down <- df_perc_ACGU_down[,c(1,3,4)]
df_perc_ACGU_down <- pivot_longer(df_perc_ACGU_down, 2:5)
df_perc_AU_down <- pivot_longer(df_perc_AU_down, 2:3)
df_perc_CG_down <- pivot_longer(df_perc_CG_down, 2:3)

df_percAU <- data.frame(cbind(ntpos=rep(c(-length_up_down:-1,1:length_up_down),2),percAU=c(perc_AU_up, perc_AU_down)*100))
df_percAU$updown <- c(rep("up",2*length_up_down), rep("down", 2*length_up_down))

general_AU <- (sum(oligonucleotideFrequency(syne_fasta, width=1)[,c(1,4)])/sum(oligonucleotideFrequency(syne_fasta, width=1)))*100

ACGU_colors <- palette_OkabeIto[c(3,1,5,6)]
names(ACGU_colors) <- c("U", "G", "C", "A")
```

Compare AU content between peak positions which are either up- or downregulated

```{r}
p <- ggplot(data=df_percAU, aes(x=ntpos, y=percAU, color=updown)) + geom_hline(aes(yintercept=general_AU), color="darkgray", linetype=2) + geom_vline(aes(xintercept=0), linetype=2, color="darkgray") + geom_line(size=.5) + theme_light() + 
  scale_color_manual(values=c("#005a96ff", "#e69f00ff"), name  ="Peaks",
                           breaks=c("up", "down"),
                           labels=c("rne(WT)>rne(5p)", "rne(5p)>rne(WT)")) + xlab("Distance Relative to Cleavage Site (nt)") + ylab("Percentage AU (%)")
  
p <- p + theme(legend.justification=c(1,1), legend.position=c(0.95,0.95), legend.background = element_rect(colour="gray", linetype="solid", fill="white", size=.5))

ggsave("output/nt_content_plots/AUcontent.pdf", plot=p, width=10, height=7, units="cm")
```

Code for disinguishing nts:

```{r}
p <- ggplot(data=df_perc_ACGU_up, aes(x=ntpos, y=value, color=name)) + geom_vline(aes(xintercept=0), linetype=2, color="darkgray") + geom_line(size=0.5) + theme_light() + scale_color_manual(name="nt", values=ACGU_colors)+ xlab("Distance Relative to Cleavage Site (nt)") + ylab("Percentage ACGU (%)") + theme(legend.justification=c(1,1), legend.position=c(0.95,0.95), legend.background = element_rect(colour="gray", linetype="solid", fill="white", size=.5)) +ylim(5,72)+xlim(-25,+25)
p
ggsave("output/nt_content_plots/ACGU_up_content.pdf", plot=p, width=10, height=7, units="cm")

p <- ggplot(data=df_perc_ACGU_down, aes(x=ntpos, y=value, color=name)) + geom_vline(aes(xintercept=0), linetype=2, color="darkgray") + geom_line(size=.5) + theme_light() + scale_color_manual(name="nt", values=ACGU_colors)+ xlab("Distance Relative to Cleavage Site (nt)") + ylab("Percentage ACGU (%)") + theme(legend.justification=c(1,1), legend.position=c(0.95,0.95), legend.background = element_rect(colour="gray", linetype="solid", fill="white", size=.5))+ylim(5,72)+xlim(-25,+25)
p
ggsave("output/nt_content_plots/ACGU_down_content.pdf", plot=p, width=10, height=7, units="cm")
```

```{r, echo=FALSE}
save.image(file = "furtherAnalyses.RData")
```
```{r, echo=FALSE}
#load("furtherAnalyses.RData")
```

# Session info {.unnumbered}

```{r sessionInfo, echo=FALSE}
sessionInfo()
```

# References {.unnumbered}